
<!doctype html>
<html lang="ja" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-8.2.4">
    
    
      
        <title>Convolution (ACL-RS) - My Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.2d9f7617.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.e6a45f82.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#convolution-acl-rs" class="md-skip">
          コンテンツにスキップ
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="ヘッダー">
    <a href="../.." title="My Docs" class="md-header__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            My Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Convolution (ACL-RS)
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="検索" placeholder="検索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="クリア" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            検索を初期化
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="ナビゲーション" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="My Docs" class="md-nav__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    My Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          Rust
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Rust" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Rust
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_1" type="checkbox" id="__nav_1_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_1">
          Math
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Math" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_1">
          <span class="md-nav__icon md-icon"></span>
          Math
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../math/integer/" class="md-nav__link">
        Integer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../math/divisor/" class="md-nav__link">
        Divisor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../math/pow_mod/" class="md-nav__link">
        PowMod
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../util/" class="md-nav__link">
        Util
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../segtree/" class="md-nav__link">
        SegTree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../maxflow/" class="md-nav__link">
        MaxFlowDinic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bisect/" class="md-nav__link">
        Bisect
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Convolution (ACL-RS)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Convolution (ACL-RS)
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目次">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目次
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    使い方
  </a>
  
    <nav class="md-nav" aria-label="使い方">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#modint" class="md-nav__link">
    ModInt 不使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modint_1" class="md-nav__link">
    ModInt 使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    例題
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../lazy_segtree/" class="md-nav__link">
        LazySegTree
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../median/" class="md-nav__link">
        Median
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目次">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目次
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    使い方
  </a>
  
    <nav class="md-nav" aria-label="使い方">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#modint" class="md-nav__link">
    ModInt 不使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modint_1" class="md-nav__link">
    ModInt 使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    例題
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="convolution-acl-rs">Convolution (ACL-RS)</h1>
<p>Thanks! <a href="https://github.com/rust-lang-ja/ac-library-rs/blob/master/src/convolution.rs">ac-library-rs</a>
<br />
<details><summary>Source Code</summary>

<div class="highlight"><pre><span></span><code><span class="c1">//https://github.com/rust-lang-ja/ac-library-rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">convolution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$($name</span>:<span class="nc">ident</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">$(</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[derive(Copy, Clone, Eq, PartialEq)]</span><span class="w"></span>
<span class="w">            </span><span class="k">enum</span> <span class="cp">$name</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">            </span><span class="k">impl</span><span class="w"> </span><span class="n">Modulus</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$name</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">HINT_VALUE_IS_PRIME</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>

<span class="w">                </span><span class="k">fn</span> <span class="nf">butterfly_cache</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> ::<span class="n">std</span>::<span class="n">thread</span>::<span class="n">LocalKey</span><span class="o">&lt;</span>::<span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="o">&lt;</span>::<span class="n">std</span>::<span class="n">option</span>::<span class="nb">Option</span><span class="o">&lt;</span><span class="k">crate</span>::<span class="n">modint</span>::<span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="fm">thread_local!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">static</span><span class="w"> </span><span class="n">BUTTERFLY_CACHE</span>: ::<span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="o">&lt;</span>::<span class="n">std</span>::<span class="n">option</span>::<span class="nb">Option</span><span class="o">&lt;</span><span class="k">crate</span>::<span class="n">modint</span>::<span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="cp">$name</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">default</span>::<span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="o">&amp;</span><span class="n">BUTTERFLY_CACHE</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="o">*</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">internal_bit</span><span class="p">,</span><span class="w"> </span><span class="n">internal_math</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">modint</span>::<span class="p">{</span><span class="n">ButterflyCache</span><span class="p">,</span><span class="w"> </span><span class="n">Modulus</span><span class="p">,</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="p">,</span><span class="w"> </span><span class="n">StaticModInt</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cmp</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">convert</span>::<span class="p">{</span><span class="n">TryFrom</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">fmt</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">convolution</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cmp</span>::<span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">StaticModInt</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">to_owned</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">internal_bit</span>::<span class="n">ceil_pow2</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">butterfly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">butterfly</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">butterfly_inv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">iz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="n">new</span><span class="p">(</span><span class="n">z</span><span class="p">).</span><span class="n">inv</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">iz</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">convolution_raw</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">where</span><span class="w"></span>
<span class="w">        </span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">T</span>::<span class="n">Error</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Into</span>::<span class="n">into</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Into</span>::<span class="n">into</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">convolution</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">z</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;the numeric type is smaller than the modulus&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">convolution_i64</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M1</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">754_974_721</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^24</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M2</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">167_772_161</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^25</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">469_762_049</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^26</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M2M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M1M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M1M2</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">M1M2M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M1M2</span><span class="p">.</span><span class="n">wrapping_mul</span><span class="p">(</span><span class="n">M3</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">,</span><span class="w"> </span><span class="n">M3</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">i1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_math</span>::<span class="n">inv_gcd</span><span class="p">(</span><span class="n">M2M3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_math</span>::<span class="n">inv_gcd</span><span class="p">(</span><span class="n">M1M3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">i3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_math</span>::<span class="n">inv_gcd</span><span class="p">(</span><span class="n">M1M2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">M3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">M3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">c1</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">c3</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">((</span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">),</span><span class="w"> </span><span class="n">c3</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">OFFSET</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u64</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M1M2M3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M1M2M3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M1M2M3</span><span class="p">];</span><span class="w"></span>

<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2M3</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">,</span><span class="w"> </span><span class="n">M1M3</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">c3</span><span class="p">,</span><span class="w"> </span><span class="n">i3</span><span class="p">,</span><span class="w"> </span><span class="n">M3</span><span class="p">,</span><span class="w"> </span><span class="n">M1M2</span><span class="p">)]</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">c</span><span class="p">.</span><span class="n">wrapping_mul</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">rem_euclid</span><span class="p">(</span><span class="n">m1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">).</span><span class="n">wrapping_mul</span><span class="p">(</span><span class="n">m2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="p">})</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">wrapping_add</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// B = 2^63, -B &lt;= x, r(real value) &lt; B</span>
<span class="w">                </span><span class="c1">// (x, x - M, x - 2M, or x - 3M) = r (mod 2B)</span>
<span class="w">                </span><span class="c1">// r = c1[i] (mod MOD1)</span>
<span class="w">                </span><span class="c1">// focus on MOD1</span>
<span class="w">                </span><span class="c1">// r = x, x - M&#39;, x - 2M&#39;, x - 3M&#39; (M&#39; = M % 2^64) (mod 2B)</span>
<span class="w">                </span><span class="c1">// r = x,</span>
<span class="w">                </span><span class="c1">//     x - M&#39; + (0 or 2B),</span>
<span class="w">                </span><span class="c1">//     x - 2M&#39; + (0, 2B or 4B),</span>
<span class="w">                </span><span class="c1">//     x - 3M&#39; + (0, 2B, 4B or 6B) (without mod!)</span>
<span class="w">                </span><span class="c1">// (r - x) = 0, (0)</span>
<span class="w">                </span><span class="c1">//           - M&#39; + (0 or 2B), (1)</span>
<span class="w">                </span><span class="c1">//           -2M&#39; + (0 or 2B or 4B), (2)</span>
<span class="w">                </span><span class="c1">//           -3M&#39; + (0 or 2B or 4B or 6B) (3) (mod MOD1)</span>
<span class="w">                </span><span class="c1">// we checked that</span>
<span class="w">                </span><span class="c1">//   ((1) mod MOD1) mod 5 = 2</span>
<span class="w">                </span><span class="c1">//   ((2) mod MOD1) mod 5 = 3</span>
<span class="w">                </span><span class="c1">//   ((3) mod MOD1) mod 5 = 4</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">internal_math</span>::<span class="n">safe_mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">diff</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">wrapping_sub</span><span class="p">(</span><span class="n">OFFSET</span><span class="p">[</span><span class="n">diff</span><span class="p">.</span><span class="n">rem_euclid</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">x</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">butterfly</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_bit</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">M</span>::<span class="n">butterfly_cache</span><span class="p">().</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">cache</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ButterflyCache</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum_e</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">get_or_insert_with</span><span class="p">(</span><span class="n">prepare</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">ph</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..=</span><span class="n">h</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">ph</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ph</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ph</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">now</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">sum_e</span><span class="p">[(</span><span class="o">!</span><span class="n">s</span><span class="p">).</span><span class="n">trailing_zeros</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">butterfly_inv</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_bit</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">M</span>::<span class="n">butterfly_cache</span><span class="p">().</span><span class="n">with</span><span class="p">(</span><span class="o">|</span><span class="n">cache</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ButterflyCache</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum_ie</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">get_or_insert_with</span><span class="p">(</span><span class="n">prepare</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">ph</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">h</span><span class="p">).</span><span class="n">rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">ph</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ph</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ph</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="n">new</span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">val</span><span class="p">())</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inow</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">inow</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">sum_ie</span><span class="p">[(</span><span class="o">!</span><span class="n">s</span><span class="p">).</span><span class="n">trailing_zeros</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">prepare</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">ButterflyCache</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">raw</span><span class="p">(</span><span class="n">internal_math</span>::<span class="n">primitive_root</span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">es</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="mi">30</span><span class="p">];</span><span class="w"> </span><span class="c1">// es[i]^(2^(2+i)) == 1</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ies</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="mi">30</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cnt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">trailing_zeros</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">pow</span><span class="p">(((</span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">cnt2</span><span class="p">).</span><span class="n">into</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">inv</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">..=</span><span class="n">cnt2</span><span class="p">).</span><span class="n">rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">es</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">ies</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ie</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">e</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">ie</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">ie</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sum_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">es</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="n">StaticModInt</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="n">acc</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sum_ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ies</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="n">StaticModInt</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">ie</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="n">acc</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">ie</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ButterflyCache</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sum_e</span><span class="p">,</span><span class="w"> </span><span class="n">sum_ie</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="w">    </span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">modint</span>::<span class="p">{</span><span class="n">Mod998244353</span><span class="p">,</span><span class="w"> </span><span class="n">Modulus</span><span class="p">,</span><span class="w"> </span><span class="n">StaticModInt</span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">RemEuclidU32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="p">{</span><span class="n">rngs</span>::<span class="n">ThreadRng</span><span class="p">,</span><span class="w"> </span><span class="n">Rng</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">convert</span>::<span class="p">{</span><span class="n">TryFrom</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">fmt</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="c1">//https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L51-L71</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="k">super</span>::<span class="n">convolution</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mf">1.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="mf">2.</span><span class="n">into</span><span class="p">()]).</span><span class="n">is_empty</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L73-L85</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">mid</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">N</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2345</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">gen_values</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen_values</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">gen_values</span><span class="p">(</span><span class="n">M</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">conv_naive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L87-L118</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_s_mod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M1</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">998_244_353</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M2</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">924_844_033</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="k">fn</span> <span class="nf">test</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadRng</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">gen_values</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">j</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen_values</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">gen_values</span><span class="p">(</span><span class="n">m</span><span class="p">));</span><span class="w"></span>
<span class="w">                    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">conv_naive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">test</span>::<span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">test</span>::<span class="o">&lt;</span><span class="n">M2</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L120-L150</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_int</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L152-L182</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_uint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L184-L214</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_ll</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L216-L246</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_ull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L249-L279</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_int128</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">i128</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L281-L311</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_uint128</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">simple_raw</span>::<span class="o">&lt;</span><span class="kt">u128</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">simple_raw</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>::<span class="n">Error</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M1</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">998_244_353</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M2</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">924_844_033</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="k">fn</span> <span class="nf">test</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadRng</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">where</span><span class="w"></span>
<span class="w">                </span><span class="n">T</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">T</span>::<span class="n">Error</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen_raw_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">gen_raw_values</span>::<span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">j</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen_raw_values</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">gen_raw_values</span><span class="p">(</span><span class="n">m</span><span class="p">));</span><span class="w"></span>
<span class="w">                    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">                        </span><span class="n">conv_raw_naive</span>::<span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="k">super</span>::<span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">test</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">test</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L315-L329</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_ll</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">j</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span>: <span class="kt">usize</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">rng</span><span class="p">.</span><span class="n">gen_range</span><span class="p">(</span><span class="o">-</span><span class="mi">500_000</span><span class="p">,</span><span class="w"> </span><span class="mi">500_000</span><span class="p">)).</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">};</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">gen</span><span class="p">(</span><span class="n">m</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">conv_i64_naive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution_i64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L331-L356</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_ll_bound</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M1</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">754_974_721</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^24</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M2</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">167_772_161</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^25</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">469_762_049</span><span class="p">;</span><span class="w"> </span><span class="c1">// 2^26</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M2M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M3</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M1M3</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M3</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M1M2</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">M1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M2</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">,</span><span class="w"> </span><span class="n">M3</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">-</span><span class="mi">1000</span><span class="o">..=</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="k">u64</span><span class="p">.</span><span class="n">wrapping_sub</span><span class="p">(</span><span class="n">M1M2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">M1M3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">M2M3</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution_i64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="kt">i64</span>::<span class="n">min_value</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution_i64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution_i64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L358-L371</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_641</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">641</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">gen_values</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen_values</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="n">gen_values</span><span class="p">(</span><span class="mi">65</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">conv_naive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L373-L386</span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_18433</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">M</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">18433</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">modulus</span><span class="o">!</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">gen_values</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gen_values</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span><span class="w"> </span><span class="n">gen_values</span><span class="p">(</span><span class="mi">1025</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">conv_naive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">super</span>::<span class="n">convolution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_naive</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">],</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="n">StaticModInt</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">j</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_raw_naive</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>::<span class="n">Error</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">conv_naive</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Into</span>::<span class="n">into</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                </span><span class="o">&amp;</span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Into</span>::<span class="n">into</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">val</span><span class="p">().</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">conv_i64_naive</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">m</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">j</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">gen_values</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadRng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">rng</span><span class="p">.</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">).</span><span class="n">into</span><span class="p">()).</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">gen_raw_values</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadRng</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">T</span>::<span class="n">Error</span>: <span class="nc">fmt</span>::<span class="n">Debug</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">rng</span><span class="p">.</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">).</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">internal_bit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Skipped:</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// - `bsf` = `__builtin_ctz`: is equivalent to `{integer}::trailing_zeros`</span>

<span class="w">    </span><span class="cp">#[allow(dead_code)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">ceil_pow2</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="mi">32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">leading_zeros</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="w">    </span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">ceil_pow2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// https://github.com/atcoder/ac-library/blob/2088c8e2431c3f4d29a2cfabc6529fe0a0586c48/test/unittest/bit_test.cpp</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">30</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="k">super</span>::<span class="n">ceil_pow2</span><span class="p">(</span><span class="kt">u32</span>::<span class="n">max_value</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">internal_math</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// remove this after dependencies has been added</span>
<span class="w">    </span><span class="cp">#![allow(dead_code)]</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">swap</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// # Arguments</span>
<span class="w">    </span><span class="sd">/// * `m` `1 &lt;= m`</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Returns</span>
<span class="w">    </span><span class="sd">/// x mod m</span>
<span class="w">    </span><span class="cm">/* const */</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">safe_mod</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">i64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Fast modular by barrett reduction</span>
<span class="w">    </span><span class="sd">/// Reference: https://en.wikipedia.org/wiki/Barrett_reduction</span>
<span class="w">    </span><span class="sd">/// NOTE: reconsider after Ice Lake</span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="n">_m</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="n">im</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// # Arguments</span>
<span class="w">        </span><span class="sd">/// * `m` `1 &lt;= m`</span>
<span class="w">        </span><span class="sd">/// (Note: `m &lt;= 2^31` should also hold, which is undocumented in the original library.</span>
<span class="w">        </span><span class="sd">/// See the [pull reqeust commment](https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484661007)</span>
<span class="w">        </span><span class="sd">/// for more details.)</span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">m</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">_m</span>: <span class="nc">m</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">im</span>: <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="k">i64</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// # Returns</span>
<span class="w">        </span><span class="sd">/// `m`</span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">umod</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">_m</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// # Parameters</span>
<span class="w">        </span><span class="sd">/// * `a` `0 &lt;= a &lt; m`</span>
<span class="w">        </span><span class="sd">/// * `b` `0 &lt;= b &lt; m`</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Returns</span>
<span class="w">        </span><span class="sd">/// a * b % m</span>
<span class="w">        </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">mul_mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_m</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">im</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Calculates `a * b % m`.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// * `a` `0 &lt;= a &lt; m`</span>
<span class="w">    </span><span class="sd">/// * `b` `0 &lt;= b &lt; m`</span>
<span class="w">    </span><span class="sd">/// * `m` `1 &lt;= m &lt;= 2^31`</span>
<span class="w">    </span><span class="sd">/// * `im` = ceil(2^64 / `m`)</span>
<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">mul_mod</span><span class="p">(</span><span class="n">a</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">im</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// [1] m = 1</span>
<span class="w">        </span><span class="c1">// a = b = im = 0, so okay</span>

<span class="w">        </span><span class="c1">// [2] m &gt;= 2</span>
<span class="w">        </span><span class="c1">// im = ceil(2^64 / m)</span>
<span class="w">        </span><span class="c1">// -&gt; im * m = 2^64 + r (0 &lt;= r &lt; m)</span>
<span class="w">        </span><span class="c1">// let z = a*b = c*m + d (0 &lt;= c, d &lt; m)</span>
<span class="w">        </span><span class="c1">// a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im</span>
<span class="w">        </span><span class="c1">// c*r + d*im &lt; m * m + m * im &lt; m * m + 2^64 + m &lt;= 2^64 + m * (m + 1) &lt; 2^64 * 2</span>
<span class="w">        </span><span class="c1">// ((ab * im) &gt;&gt; 64) == c or c + 1</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">z</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">z</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u128</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">im</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u128</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">wrapping_sub</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">wrapping_mul</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">v</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// # Parameters</span>
<span class="w">    </span><span class="sd">/// * `n` `0 &lt;= n`</span>
<span class="w">    </span><span class="sd">/// * `m` `1 &lt;= m`</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Returns</span>
<span class="w">    </span><span class="sd">/// `(x ** n) % m`</span>
<span class="w">    </span><span class="cm">/* const */</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pow_mod</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">safe_mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">_m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">_m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Reference:</span>
<span class="w">    </span><span class="sd">/// M. Forisek and J. Jancina,</span>
<span class="w">    </span><span class="sd">/// Fast Primality Testing for Integers That Fit into a Machine Word</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Parameters</span>
<span class="w">    </span><span class="sd">/// * `n` `0 &lt;= n`</span>
<span class="w">    </span><span class="cm">/* const */</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">61</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">d</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">61</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow_mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// omitted</span>
<span class="w">    </span><span class="c1">// template &lt;int n&gt; constexpr bool is_prime = is_prime_constexpr(n);</span>

<span class="w">    </span><span class="sd">/// # Parameters</span>
<span class="w">    </span><span class="sd">/// * `b` `1 &lt;= b`</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Returns</span>
<span class="w">    </span><span class="sd">/// (g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 &lt;= x &lt; b/g</span>
<span class="w">    </span><span class="cm">/* const */</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[allow(clippy::many_single_char_names)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">inv_gcd</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">safe_mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Contracts:</span>
<span class="w">        </span><span class="c1">// [1] s - m0 * a = 0 (mod b)</span>
<span class="w">        </span><span class="c1">// [2] t - m1 * a = 0 (mod b)</span>
<span class="w">        </span><span class="c1">// [3] s * |m1| + t * |m0| &lt;= b</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">s</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">m0</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">// |m1 * u| &lt;= |m1| * s &lt;= b</span>

<span class="w">            </span><span class="c1">// [3]:</span>
<span class="w">            </span><span class="c1">// (s - t * u) * |m1| + t * |m0 - m1 * u|</span>
<span class="w">            </span><span class="c1">// &lt;= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)</span>
<span class="w">            </span><span class="c1">// = s * |m1| + t * |m0| &lt;= b</span>

<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">m1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// by [3]: |m0| &lt;= b/g</span>
<span class="w">        </span><span class="c1">// by g != b: |m0| &lt; b/g</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">m0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">m0</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">m0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Compile time (currently not) primitive root</span>
<span class="w">    </span><span class="sd">/// @param m must be prime</span>
<span class="w">    </span><span class="sd">/// @return primitive root (and minimum in now)</span>
<span class="w">    </span><span class="cm">/* const */</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span> <span class="nf">primitive_root</span><span class="p">(</span><span class="n">m</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">167_772_161</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">469_762_049</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">754_974_721</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">998_244_353</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">divs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">20</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">divs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="o">..</span><span class="n">std</span>::<span class="kt">i32</span>::<span class="n">MAX</span><span class="p">).</span><span class="n">step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">divs</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">cnt</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">divs</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">cnt</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">cnt</span><span class="p">).</span><span class="n">all</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">pow_mod</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">g</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// omitted</span>
<span class="w">    </span><span class="c1">// template &lt;int m&gt; constexpr int primitive_root = primitive_root_constexpr(m);</span>

<span class="w">    </span><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="w">    </span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#![allow(clippy::unreadable_literal)]</span><span class="w"></span>
<span class="w">        </span><span class="cp">#![allow(clippy::cognitive_complexity)]</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">internal_math</span>::<span class="p">{</span><span class="n">inv_gcd</span><span class="p">,</span><span class="w"> </span><span class="n">is_prime</span><span class="p">,</span><span class="w"> </span><span class="n">pow_mod</span><span class="p">,</span><span class="w"> </span><span class="n">primitive_root</span><span class="p">,</span><span class="w"> </span><span class="n">safe_mod</span><span class="p">,</span><span class="w"> </span><span class="n">Barrett</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashSet</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_safe_mod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">73</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">),</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="mi">2306249155046129918</span><span class="p">,</span><span class="w"> </span><span class="mi">6620319213327</span><span class="p">),</span><span class="w"> </span><span class="mi">1374210749525</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">safe_mod</span><span class="p">(</span><span class="o">-</span><span class="mi">7170500492396019511</span><span class="p">,</span><span class="w"> </span><span class="mi">777567337</span><span class="p">),</span><span class="w"> </span><span class="mi">333221848</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_barrett</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Barrett</span>::<span class="n">new</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">umod</span><span class="p">(),</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Barrett</span>::<span class="n">new</span><span class="p">(</span><span class="mi">998244353</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">umod</span><span class="p">(),</span><span class="w"> </span><span class="mi">998244353</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">3141592</span><span class="p">,</span><span class="w"> </span><span class="mi">653589</span><span class="p">),</span><span class="w"> </span><span class="mi">919583920</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">323846264</span><span class="p">,</span><span class="w"> </span><span class="mi">338327950</span><span class="p">),</span><span class="w"> </span><span class="mi">568012980</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="c1">// make `z - x * self._m as u64` overflow.</span>
<span class="w">            </span><span class="c1">// Thanks @koba-e964 (at https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484932161)</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Barrett</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">umod</span><span class="p">(),</span><span class="w"> </span><span class="mi">2147483647</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">1073741824</span><span class="p">,</span><span class="w"> </span><span class="mi">2147483645</span><span class="p">),</span><span class="w"> </span><span class="mi">2147483646</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_pow_mod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">723</span><span class="p">),</span><span class="w"> </span><span class="mi">640</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">998244353</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="mi">683296792</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">pow_mod</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"></span>
<span class="w">                </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1_000_000_007</span><span class="p">),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1_000_000_007</span><span class="p">),</span><span class="w"> </span><span class="mi">78125</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">456</span><span class="p">,</span><span class="w"> </span><span class="mi">1_000_000_007</span><span class="p">),</span><span class="w"> </span><span class="mi">565291922</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_is_prime</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span><span class="w"></span>

<span class="w">            </span><span class="c1">// assert!(is_prime(57));</span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">57</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">58</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">59</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">60</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">61</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">62</span><span class="p">));</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">701928443</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">998244353</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">1_000_000_000</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="mi">1_000_000_007</span><span class="p">));</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_is_prime_sieve</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1_000_000</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">prime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="n">step_by</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_inv_gcd</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">57</span><span class="p">,</span><span class="w"> </span><span class="mi">81</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span><span class="w"> </span><span class="mi">67890</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="o">-</span><span class="mi">3141592</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6535</span><span class="p">,</span><span class="w"> </span><span class="mi">3141592</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8979</span><span class="p">,</span><span class="w"> </span><span class="mi">3141592</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">()),</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="kt">i64</span>::<span class="n">min_value</span><span class="p">(),</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">g_</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inv_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">g_</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">b_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(((</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b_</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b_</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">test_primitive_root</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="w"></span>
<span class="w">                </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">233</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">200003</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">998244353</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">1_000_000_007</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">));</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">primitive_root</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="fm">assert_ne!</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="kt">i32</span>::<span class="n">max_value</span><span class="p">()).</span><span class="n">take_while</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="fm">assert_ne!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pow_mod</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1_000_000</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="w"></span>
<span class="w">                        </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Some</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">})</span><span class="w"></span>
<span class="w">                            </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">                            </span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                    </span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">modint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">//! Structs that treat the modular arithmetic.</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! For most of the problems, It is sufficient to use [`ModInt1000000007`] or [`ModInt998244353`], which can be used as follows.</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! ```</span>
<span class="w">    </span><span class="sd">//! use ac_library_rs::ModInt1000000007 as Mint; // rename to whatever you want</span>
<span class="w">    </span><span class="sd">//! use proconio::{input, source::once::OnceSource};</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! input! {</span>
<span class="w">    </span><span class="sd">//!     from OnceSource::from(&quot;1000000006 2\n&quot;),</span>
<span class="w">    </span><span class="sd">//!     a: Mint,</span>
<span class="w">    </span><span class="sd">//!     b: Mint,</span>
<span class="w">    </span><span class="sd">//! }</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! println!(&quot;{}&quot;, a + b); // `1`</span>
<span class="w">    </span><span class="sd">//! ```</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! If the modulus is not fixed, you can use [`ModInt`] as follows.</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! ```</span>
<span class="w">    </span><span class="sd">//! use ac_library_rs::ModInt as Mint; // rename to whatever you want</span>
<span class="w">    </span><span class="sd">//! use proconio::{input, source::once::OnceSource};</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! input! {</span>
<span class="w">    </span><span class="sd">//!     from OnceSource::from(&quot;3 3 7\n&quot;),</span>
<span class="w">    </span><span class="sd">//!     a: u32,</span>
<span class="w">    </span><span class="sd">//!     b: u32,</span>
<span class="w">    </span><span class="sd">//!     m: u32,</span>
<span class="w">    </span><span class="sd">//! }</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! Mint::set_modulus(m);</span>
<span class="w">    </span><span class="sd">//! let a = Mint::new(a);</span>
<span class="w">    </span><span class="sd">//! let b = Mint::new(b);</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! println!(&quot;{}&quot;, a * b); // `2`</span>
<span class="w">    </span><span class="sd">//! ```</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! # Major changes from the original ACL</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! - Converted the struct names to PascalCase.</span>
<span class="w">    </span><span class="sd">//! - Renamed `mod` → `modulus`.</span>
<span class="w">    </span><span class="sd">//! - Moduli are `u32`, not `i32`.</span>
<span class="w">    </span><span class="sd">//! - Each `Id` does not have a identifier number. Instead, they explicitly own `&amp;&#39;static LocalKey&lt;RefCell&lt;Barrett&gt;&gt;`.</span>
<span class="w">    </span><span class="sd">//! - The type of the argument of `pow` is `u64`, not `i64`.</span>
<span class="w">    </span><span class="sd">//! - Modints implement `FromStr` and `Display`. Modints in the original ACL don&#39;t have `operator&lt;&lt;` or `operator&gt;&gt;`.</span>
<span class="w">    </span><span class="sd">//!</span>
<span class="w">    </span><span class="sd">//! [`ModInt1000000007`]: ./type.ModInt1000000007.html</span>
<span class="w">    </span><span class="sd">//! [`ModInt998244353`]: ./type.ModInt998244353.html</span>
<span class="w">    </span><span class="sd">//! [`ModInt`]: ./type.ModInt.html</span>

<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">internal_math</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cell</span>::<span class="n">RefCell</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">convert</span>::<span class="p">{</span><span class="n">Infallible</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">fmt</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">hash</span>::<span class="p">{</span><span class="n">Hash</span><span class="p">,</span><span class="w"> </span><span class="n">Hasher</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">iter</span>::<span class="p">{</span><span class="n">Product</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ops</span>::<span class="p">{</span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="n">AddAssign</span><span class="p">,</span><span class="w"> </span><span class="n">Div</span><span class="p">,</span><span class="w"> </span><span class="n">DivAssign</span><span class="p">,</span><span class="w"> </span><span class="n">Mul</span><span class="p">,</span><span class="w"> </span><span class="n">MulAssign</span><span class="p">,</span><span class="w"> </span><span class="n">Neg</span><span class="p">,</span><span class="w"> </span><span class="n">Sub</span><span class="p">,</span><span class="w"> </span><span class="n">SubAssign</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="kt">str</span>::<span class="n">FromStr</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">sync</span>::<span class="n">atomic</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicU32</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicU64</span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">thread</span>::<span class="n">LocalKey</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">ModInt1000000007</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">Mod1000000007</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">ModInt998244353</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">ModInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">DefaultId</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Represents _ℤ/mℤ_ where _m_ is a constant value.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// Corresponds to `atcoder::static_modint` in the original ACL.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Example</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="sd">/// use ac_library_rs::ModInt1000000007 as Mint;</span>
<span class="w">    </span><span class="sd">/// use proconio::{input, source::once::OnceSource};</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// input! {</span>
<span class="w">    </span><span class="sd">///     from OnceSource::from(&quot;1000000006 2\n&quot;),</span>
<span class="w">    </span><span class="sd">///     a: Mint,</span>
<span class="w">    </span><span class="sd">///     b: Mint,</span>
<span class="w">    </span><span class="sd">/// }</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// println!(&quot;{}&quot;, a + b); // `1`</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="cp">#[derive(Copy, Clone, Eq, PartialEq)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">val</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">M</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// Returns the modulus, which is [`&lt;M as Modulus&gt;::VALUE`].</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::mod` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::ModInt1000000007 as Mint;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// assert_eq!(1_000_000_007, Mint::modulus());</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [`&lt;M as Modulus&gt;::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE</span>
<span class="w">        </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">modulus</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Creates a new `StaticModInt`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Takes [any primitive integer].</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to the constructor of `atcoder::static_modint` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [any primitive integer]:  ../trait.RemEuclidU32.html</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">rem_euclid_u32</span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Constructs a `StaticModInt` from a `val &lt; Self::modulus()` without checking it.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::raw` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Constraints</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// - `val` is less than `Self::modulus()`</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// See [`ModIntBase::raw`] for more more details.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">val</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the representative.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::val` in the original ACL.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Returns `self` to the power of `n`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::pow` in the original ACL.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">ModIntBase</span><span class="o">&gt;</span>::<span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the multiplicative inverse of `self`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::inv` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Panics</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Panics if the multiplicative inverse does not exist.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">M</span>::<span class="n">HINT_VALUE_IS_PRIME</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;attempt to divide by zero&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="fm">debug_assert!</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">internal_math</span>::<span class="n">is_prime</span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()),</span><span class="w"></span>
<span class="w">                    </span><span class="s">&quot;{} is not a prime number&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">pow</span><span class="p">((</span><span class="n">M</span>::<span class="n">VALUE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">inv_for_non_prime_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// These methods are implemented for the struct.</span>
<span class="w">    </span><span class="sd">/// You don&#39;t need to `use` `ModIntBase` to call methods of `StaticModInt`.</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ModIntBase</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">modulus</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">raw</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">inv</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Represents a modulus.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Example</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="sd">/// macro_rules! modulus {</span>
<span class="w">    </span><span class="sd">///     ($($name:ident($value:expr, $is_prime:expr)),*) =&gt; {</span>
<span class="w">    </span><span class="sd">///         $(</span>
<span class="w">    </span><span class="sd">///             #[derive(Copy, Clone, Eq, PartialEq)]</span>
<span class="w">    </span><span class="sd">///             enum $name {}</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">///             impl ac_library_rs::modint::Modulus for $name {</span>
<span class="w">    </span><span class="sd">///                 const VALUE: u32 = $value;</span>
<span class="w">    </span><span class="sd">///                 const HINT_VALUE_IS_PRIME: bool = $is_prime;</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">///                 fn butterfly_cache() -&gt; &amp;&#39;static ::std::thread::LocalKey&lt;::std::cell::RefCell&lt;::std::option::Option&lt;ac_library_rs::modint::ButterflyCache&lt;Self&gt;&gt;&gt;&gt; {</span>
<span class="w">    </span><span class="sd">///                     thread_local! {</span>
<span class="w">    </span><span class="sd">///                         static BUTTERFLY_CACHE: ::std::cell::RefCell&lt;::std::option::Option&lt;ac_library_rs::modint::ButterflyCache&lt;$name&gt;&gt;&gt; = ::std::default::Default::default();</span>
<span class="w">    </span><span class="sd">///                     }</span>
<span class="w">    </span><span class="sd">///                     &amp;BUTTERFLY_CACHE</span>
<span class="w">    </span><span class="sd">///                 }</span>
<span class="w">    </span><span class="sd">///             }</span>
<span class="w">    </span><span class="sd">///         )*</span>
<span class="w">    </span><span class="sd">///     };</span>
<span class="w">    </span><span class="sd">/// }</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// use ac_library_rs::StaticModInt;</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// modulus!(Mod101(101, true), Mod103(103, true));</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// type Z101 = StaticModInt&lt;Mod101&gt;;</span>
<span class="w">    </span><span class="sd">/// type Z103 = StaticModInt&lt;Mod103&gt;;</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// assert_eq!(Z101::new(101), Z101::new(0));</span>
<span class="w">    </span><span class="sd">/// assert_eq!(Z103::new(103), Z103::new(0));</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Modulus</span>: <span class="o">&#39;</span><span class="nb">static</span> <span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">HINT_VALUE_IS_PRIME</span>: <span class="kt">bool</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">butterfly_cache</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="nc">LocalKey</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Represents _1000000007_.</span>
<span class="w">    </span><span class="cp">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Mod1000000007</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Modulus</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mod1000000007</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1_000_000_007</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">HINT_VALUE_IS_PRIME</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">butterfly_cache</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="nc">LocalKey</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">thread_local!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">static</span><span class="w"> </span><span class="n">BUTTERFLY_CACHE</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="n">Mod1000000007</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">default</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">BUTTERFLY_CACHE</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Represents _998244353_.</span>
<span class="w">    </span><span class="cp">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Mod998244353</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Modulus</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mod998244353</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">VALUE</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">998_244_353</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">HINT_VALUE_IS_PRIME</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">butterfly_cache</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="nc">LocalKey</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">thread_local!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">static</span><span class="w"> </span><span class="n">BUTTERFLY_CACHE</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ButterflyCache</span><span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">default</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">BUTTERFLY_CACHE</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Cache for butterfly operations.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ButterflyCache</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="n">sum_e</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="n">sum_ie</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Represents _ℤ/mℤ_ where _m_ is a dynamic value.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint` in the original ACL.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// # Example</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="sd">/// use ac_library_rs::ModInt as Mint;</span>
<span class="w">    </span><span class="sd">/// use proconio::{input, source::once::OnceSource};</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// input! {</span>
<span class="w">    </span><span class="sd">///     from OnceSource::from(&quot;3 3 7\n&quot;),</span>
<span class="w">    </span><span class="sd">///     a: u32,</span>
<span class="w">    </span><span class="sd">///     b: u32,</span>
<span class="w">    </span><span class="sd">///     m: u32,</span>
<span class="w">    </span><span class="sd">/// }</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// Mint::set_modulus(m);</span>
<span class="w">    </span><span class="sd">/// let a = Mint::new(a);</span>
<span class="w">    </span><span class="sd">/// let b = Mint::new(b);</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// println!(&quot;{}&quot;, a * b); // `2`</span>
<span class="w">    </span><span class="sd">/// ```</span>
<span class="w">    </span><span class="cp">#[derive(Copy, Clone, Eq, PartialEq)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">val</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">I</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// Returns the modulus.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint::mod` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::ModInt as Mint;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// assert_eq!(998_244_353, Mint::modulus()); // default modulus</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">modulus</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">I</span>::<span class="n">companion_barrett</span><span class="p">().</span><span class="n">umod</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Sets a modulus.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint::set_mod` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Constraints</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// - This function must be called earlier than any other operation of `Self`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::ModInt as Mint;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Mint::set_modulus(7);</span>
<span class="w">        </span><span class="sd">/// assert_eq!(7, Mint::modulus());</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">set_modulus</span><span class="p">(</span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;the modulus must not be 0&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">I</span>::<span class="n">companion_barrett</span><span class="p">().</span><span class="n">update</span><span class="p">(</span><span class="n">modulus</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Creates a new `DynamicModInt`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Takes [any primitive integer].</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to the constructor of `atcoder::dynamic_modint` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [any primitive integer]:  ../trait.RemEuclidU32.html</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">ModIntBase</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Constructs a `DynamicModInt` from a `val &lt; Self::modulus()` without checking it.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint::raw` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Constraints</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// - `val` is less than `Self::modulus()`</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// See [`ModIntBase::raw`] for more more details.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">val</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the representative.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::val` in the original ACL.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Returns `self` to the power of `n`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint::pow` in the original ACL.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;</span><span class="bp">Self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">ModIntBase</span><span class="o">&gt;</span>::<span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the multiplicative inverse of `self`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::dynamic_modint::inv` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Panics</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Panics if the multiplicative inverse does not exist.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">inv_for_non_prime_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// These methods are implemented for the struct.</span>
<span class="w">    </span><span class="sd">/// You don&#39;t need to `use` `ModIntBase` to call methods of `DynamicModInt`.</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ModIntBase</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">modulus</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">raw</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">inv</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Id</span>: <span class="o">&#39;</span><span class="nb">static</span> <span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">companion_barrett</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="nc">Barrett</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">DefaultId</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Id</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DefaultId</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">companion_barrett</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="nc">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">static</span><span class="w"> </span><span class="n">BARRETT</span>: <span class="nc">Barrett</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Barrett</span>::<span class="n">default</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">BARRETT</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Pair of _m_ and _ceil(2⁶⁴/m)_.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">m</span>: <span class="nc">AtomicU32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">im</span>: <span class="nc">AtomicU64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// Creates a new `Barrett`.</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">m</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">m</span>: <span class="nc">AtomicU32</span>::<span class="n">new</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="n">im</span>: <span class="nc">AtomicU64</span>::<span class="n">new</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="k">i64</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="mi">998_244_353</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="k">i64</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">atomic</span>::<span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">im</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="w"> </span><span class="n">atomic</span>::<span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">umod</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">atomic</span>::<span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">atomic</span>::<span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">im</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">atomic</span>::<span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">internal_math</span>::<span class="n">mul_mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">im</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Barrett</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">default</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// A trait for [`StaticModInt`] and [`DynamicModInt`].</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// Corresponds to `atcoder::internal::modint_base` in the original ACL.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// [`StaticModInt`]: ../struct.StaticModInt.html</span>
<span class="w">    </span><span class="sd">/// [`DynamicModInt`]: ../struct.DynamicModInt.html</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">ModIntBase</span>:
        <span class="nb">Default</span>
        <span class="o">+</span><span class="w"> </span><span class="n">FromStr</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i16</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i128</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">isize</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">u128</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Neg</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Sub</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">Div</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">AddAssign</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">SubAssign</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">MulAssign</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">DivAssign</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// Returns the modulus.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;() {</span>
<span class="w">        </span><span class="sd">///     let _: u32 = Z::modulus();</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">modulus</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Constructs a `Self` from a `val &lt; Self::modulus()` without checking it.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Constraints</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// - `val` is less than `Self::modulus()`</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// **Note that all operations assume that inner values are smaller than the modulus.**</span>
<span class="w">        </span><span class="sd">/// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```should_panic</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::ModInt1000000007 as Mint;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// let x = Mint::raw(1_000_000_007);</span>
<span class="w">        </span><span class="sd">/// let y = x + x;</span>
<span class="w">        </span><span class="sd">/// assert_eq!(0, y.val());</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```text</span>
<span class="w">        </span><span class="sd">/// thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`</span>
<span class="w">        </span><span class="sd">///   left: `0`,</span>
<span class="w">        </span><span class="sd">///  right: `1000000007`&#39;, src/modint.rs:8:1</span>
<span class="w">        </span><span class="sd">/// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;() -&gt; Z {</span>
<span class="w">        </span><span class="sd">///     debug_assert!(Z::modulus() &gt;= 100);</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">///     let mut acc = Z::new(0);</span>
<span class="w">        </span><span class="sd">///     for i in 0..100 {</span>
<span class="w">        </span><span class="sd">///         if i % 3 == 0 {</span>
<span class="w">        </span><span class="sd">///             // I know `i` is smaller than the modulus!</span>
<span class="w">        </span><span class="sd">///             acc += Z::raw(i);</span>
<span class="w">        </span><span class="sd">///         }</span>
<span class="w">        </span><span class="sd">///     }</span>
<span class="w">        </span><span class="sd">///     acc</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">raw</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the representative.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;(x: Z) {</span>
<span class="w">        </span><span class="sd">///     let _: u32 = x.val();</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Retruns the multiplicative inverse of `self`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Panics</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Panics if the multiplicative inverse does not exist.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;(x: Z) {</span>
<span class="w">        </span><span class="sd">///     let _: Z = x.inv();</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Creates a new `Self`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Takes [any primitive integer].</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;() {</span>
<span class="w">        </span><span class="sd">///     let _ = Z::new(1u32);</span>
<span class="w">        </span><span class="sd">///     let _ = Z::new(1usize);</span>
<span class="w">        </span><span class="sd">///     let _ = Z::new(-1i64);</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// [any primitive integer]:  ../trait.RemEuclidU32.html</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">rem_euclid_u32</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="sd">/// Returns `self` to the power of `n`.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL.</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// # Example</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="sd">/// use ac_library_rs::modint::ModIntBase;</span>
<span class="w">        </span><span class="sd">///</span>
<span class="w">        </span><span class="sd">/// fn f&lt;Z: ModIntBase&gt;() {</span>
<span class="w">        </span><span class="sd">///     let _: Z = Z::new(2).pow(3);</span>
<span class="w">        </span><span class="sd">/// }</span>
<span class="w">        </span><span class="sd">/// ```</span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">r</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">r</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="sd">/// Calculates `self` _mod_ `modulus` losslessly.</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">rem_euclid_u32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_rem_euclid_u32_for_small_signed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$($ty</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">$(</span><span class="w"></span>
<span class="w">            </span><span class="k">impl</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">                </span><span class="k">fn</span> <span class="nf">rem_euclid_u32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="bp">self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">).</span><span class="n">rem_euclid</span><span class="p">(</span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">modulus</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="o">*</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_rem_euclid_u32_for_small_signed</span><span class="o">!</span><span class="p">(</span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">isize</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i128</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">rem_euclid_u32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">rem_euclid</span><span class="p">(</span><span class="kt">i128</span>::<span class="n">from</span><span class="p">(</span><span class="n">modulus</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_rem_euclid_u32_for_small_unsigned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$($ty</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">$(</span><span class="w"></span>
<span class="w">            </span><span class="k">impl</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">                </span><span class="k">fn</span> <span class="nf">rem_euclid_u32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="bp">self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">modulus</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="o">*</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_rem_euclid_u32_for_large_unsigned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$($ty</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">$(</span><span class="w"></span>
<span class="w">            </span><span class="k">impl</span><span class="w"> </span><span class="n">RemEuclidU32</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">                </span><span class="k">fn</span> <span class="nf">rem_euclid_u32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">modulus</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">modulus</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="cp">$ty</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="o">*</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_rem_euclid_u32_for_small_unsigned</span><span class="o">!</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">impl_rem_euclid_u32_for_large_unsigned</span><span class="o">!</span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u128</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(target_pointer_width = </span><span class="s">&quot;32&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">impl_rem_euclid_u32_for_small_unsigned</span><span class="o">!</span><span class="p">(</span><span class="kt">usize</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(target_pointer_width = </span><span class="s">&quot;64&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">impl_rem_euclid_u32_for_large_unsigned</span><span class="o">!</span><span class="p">(</span><span class="kt">usize</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">InternalImplementations</span>: <span class="nc">ModIntBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">inv_for_non_prime_modulus</span><span class="p">(</span><span class="n">this</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal_math</span>::<span class="n">inv_gcd</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">().</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">().</span><span class="n">into</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">gcd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;the multiplicative inverse does not exist&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">default_impl</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">from_str_impl</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Infallible</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">new</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;parsing as an arbitrary precision integer?&quot;</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">hash_impl</span><span class="p">(</span><span class="n">this</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Hasher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">().</span><span class="n">hash</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">display_impl</span><span class="p">(</span><span class="n">this</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">fmt</span>::<span class="n">Display</span>::<span class="n">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">(),</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">debug_impl</span><span class="p">(</span><span class="n">this</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">fmt</span>::<span class="n">Debug</span>::<span class="n">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">(),</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">neg_impl</span><span class="p">(</span><span class="n">this</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">sub_impl</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">this</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">add_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">val</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">modulus</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">sub_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">modulus</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span><span class="p">().</span><span class="n">wrapping_sub</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">modulus</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">fn</span> <span class="nf">mul_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">div_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">mul_impl</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">inv</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">InternalImplementations</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">mul_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">((</span><span class="kt">u64</span>::<span class="n">from</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span><span class="p">())</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">())</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from</span><span class="p">(</span><span class="n">M</span>::<span class="n">VALUE</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="o">&gt;</span><span class="w"> </span><span class="n">InternalImplementations</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">mul_impl</span><span class="p">(</span><span class="n">lhs</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="n">I</span>::<span class="n">companion_barrett</span><span class="p">().</span><span class="n">mul</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_basic_traits</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$generic_param</span>:<span class="nc">ident</span><span class="w"> </span>: <span class="cp">$generic_param_bound</span>:<span class="nc">tt</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span>:<span class="nc">ty</span><span class="p">;</span><span class="w"> </span><span class="cp">$($rest</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">default_impl</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">Infallible</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Infallible</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">from_str_impl</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">,</span><span class="w"> </span><span class="n">V</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">from</span>: <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[allow(clippy::derive_hash_xor_eq)]</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">hash_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">display_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">debug_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Neg</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$self</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="bp">Self</span>::<span class="n">neg_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Neg</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$self</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;</span><span class="cp">$self</span><span class="o">&gt;</span>::<span class="n">neg_impl</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">impl_basic_traits</span><span class="o">!</span><span class="p">(</span><span class="cp">$($rest</span><span class="p">)</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_basic_traits</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_bin_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">for</span><span class="o">&lt;</span><span class="cp">$($generic_param</span>:<span class="nc">ident</span><span class="w"> </span>: <span class="cp">$generic_param_bound</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$lhs_ty</span>:<span class="nc">ty</span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$rhs_ty</span>:<span class="nc">ty</span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="cp">$output</span>:<span class="nc">ty</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$lhs_body</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$rhs_body</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cp">$($rest</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$output</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;</span><span class="cp">$output</span><span class="o">&gt;</span>::<span class="n">add_impl</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="cp">$lhs_body</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Sub</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$output</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;</span><span class="cp">$output</span><span class="o">&gt;</span>::<span class="n">sub_impl</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="cp">$lhs_body</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$output</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;</span><span class="cp">$output</span><span class="o">&gt;</span>::<span class="n">mul_impl</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="cp">$lhs_body</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Div</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$output</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="cp">$output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;</span><span class="cp">$output</span><span class="o">&gt;</span>::<span class="n">div_impl</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="cp">$lhs_body</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">impl_bin_ops</span><span class="o">!</span><span class="p">(</span><span class="cp">$($rest</span><span class="p">)</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_assign_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">for</span><span class="o">&lt;</span><span class="cp">$($generic_param</span>:<span class="nc">ident</span><span class="w"> </span>: <span class="cp">$generic_param_bound</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$lhs_ty</span>:<span class="nc">ty</span><span class="o">&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$rhs_ty</span>:<span class="nc">ty</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$rhs_body</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cp">$($rest</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">SubAssign</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">sub_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">MulAssign</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">mul_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="w"> </span><span class="o">&lt;</span><span class="cp">$($generic_param</span>: <span class="cp">$generic_param_bound</span><span class="p">),</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">DivAssign</span><span class="o">&lt;</span><span class="cp">$rhs_ty</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$lhs_ty</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">div_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="cp">$rhs_ty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="cp">$rhs_body</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">impl_assign_ops</span><span class="o">!</span><span class="p">(</span><span class="cp">$($rest</span><span class="p">)</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">apply</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">O</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="nc">X</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">O</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_bin_ops</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span>-&gt; <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span>-&gt; <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">new</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">DynamicModInt</span>::<span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span>::<span class="n">new</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_assign_ops</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;&amp;&#39;</span><span class="nb">_</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">StaticModInt</span>::<span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span>::<span class="n">new</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="p">,</span><span class="w">      </span><span class="n">T</span>: <span class="nc">RemEuclidU32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">DynamicModInt</span>::<span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span>::<span class="n">new</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_folding</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>:<span class="nc">ident</span><span class="w"> </span>: <span class="cp">$generic_param_bound</span>:<span class="nc">tt</span><span class="o">&gt;</span><span class="w"> </span><span class="cp">$trait</span>:<span class="nc">ident</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span>:<span class="nc">ty</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="cp">$method</span>:<span class="nc">ident</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="cp">$unit</span>:<span class="nc">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$op</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cp">$($rest</span>:<span class="nc">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="cp">$trait</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="cp">$method</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"></span>
<span class="w">            </span><span class="k">where</span><span class="w"></span>
<span class="w">                </span><span class="n">S</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">iter</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="cp">$unit</span><span class="p">,</span><span class="w"> </span><span class="cp">$op</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="cp">$generic_param</span>: <span class="cp">$generic_param_bound</span><span class="o">&gt;</span><span class="w"> </span><span class="cp">$trait</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="cp">$self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#[inline]</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="cp">$method</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"></span>
<span class="w">            </span><span class="k">where</span><span class="w"></span>
<span class="w">                </span><span class="n">S</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">iter</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="cp">$unit</span><span class="p">,</span><span class="w"> </span><span class="cp">$op</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">impl_folding</span><span class="o">!</span><span class="p">(</span><span class="cp">$($rest</span><span class="p">)</span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">impl_folding</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sum</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w">     </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Add</span>::<span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Modulus</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Product</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">StaticModInt</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">product</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Mul</span>::<span class="n">mul</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sum</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w">     </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Add</span>::<span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">Id</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Product</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DynamicModInt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">product</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Mul</span>::<span class="n">mul</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="w">    </span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">modint</span>::<span class="n">ModInt1000000007</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_new</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="k">u32</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="k">u32</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1_000_000_008</span><span class="k">u32</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="k">u64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="k">u64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1_000_000_008</span><span class="k">u64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="k">usize</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="k">usize</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1_000_000_008</span><span class="k">usize</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="k">i64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="k">i64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1_000_000_008</span><span class="k">i64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1_000_000_006</span><span class="p">,</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="k">i64</span><span class="p">).</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_add</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">lhs</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">rhs</span><span class="p">)).</span><span class="n">val</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1_000_000_006</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_sub</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">sub</span><span class="p">(</span><span class="n">lhs</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">rhs</span><span class="p">)).</span><span class="n">val</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">sub</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1_000_000_006</span><span class="p">,</span><span class="w"> </span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_mul</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="n">lhs</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">rhs</span><span class="p">)).</span><span class="n">val</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">999_999_937</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="mi">100_000</span><span class="p">,</span><span class="w"> </span><span class="mi">100_000</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_prime_div</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">div</span><span class="p">(</span><span class="n">lhs</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="n">rhs</span><span class="p">)).</span><span class="n">val</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">div</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">div</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">23_809_524</span><span class="p">,</span><span class="w"> </span><span class="n">div</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_sum</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">values</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">ModInt1000000007</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">values</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">).</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">]));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_product</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">fn</span> <span class="nf">product</span><span class="p">(</span><span class="n">values</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">ModInt1000000007</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">values</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">).</span><span class="n">product</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">120</span><span class="p">),</span><span class="w"> </span><span class="n">product</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">]));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_binop_coercion</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10_293_812_</span><span class="k">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9_083_240_982_</span><span class="k">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">static_modint_assign_coercion</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ModInt1000000007</span>::<span class="n">new</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">10_293_812_</span><span class="k">usize</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9_083_240_982_</span><span class="k">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">c</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">convolution</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">modint</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

</details></p>
<h2 id="_1">使い方</h2>
<h3 id="modint">ModInt 不使用</h3>
<p><div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">cl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bl</span><span class="p">);</span><span class="w">  </span>
</code></pre></div>
それぞれの型は <code>Vec&lt;i64&gt;</code>  </p>
<h3 id="modint_1">ModInt 使用</h3>
<p><div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">cml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aml</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bml</span><span class="p">);</span><span class="w">  </span>
</code></pre></div>
それぞれの型は <code>Vec&lt;StaticModInt&lt;Mod998244353&gt;&gt;</code>  </p>
<h2 id="_2">例題</h2>
<p><a href="https://atcoder.jp/contests/practice2/tasks/practice2_f">ACL-F</a>: 畳み込みの結果を Mod で求めるだけ</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">solve1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">input</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">al</span>: <span class="p">[</span><span class="kt">i64</span><span class="w"> </span><span class="p">;</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="n">bl</span>: <span class="p">[</span><span class="kt">i64</span><span class="w"> </span><span class="p">;</span><span class="n">m</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ModInt 不使用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution_raw</span>::<span class="o">&lt;</span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bl</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cl</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&quot;{} &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">solve2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">input</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">al</span>: <span class="p">[</span><span class="kt">i64</span><span class="w"> </span><span class="p">;</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="n">bl</span>: <span class="p">[</span><span class="kt">i64</span><span class="w"> </span><span class="p">;</span><span class="n">m</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ModInt 使用</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">aml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">al</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">ModInt998244353</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">)).</span><span class="n">collect_vec</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bl</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">ModInt998244353</span>::<span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">)).</span><span class="n">collect_vec</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convolution</span>::<span class="o">&lt;</span><span class="n">Mod998244353</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aml</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bml</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cml</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&quot;{} &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="フッター">
      
        
        <a href="../bisect/" class="md-footer__link md-footer__link--prev" aria-label="前: Bisect" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                前
              </span>
              Bisect
            </div>
          </div>
        </a>
      
      
        
        <a href="../lazy_segtree/" class="md-footer__link md-footer__link--next" aria-label="次: LazySegTree" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                次
              </span>
              LazySegTree
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "\u30af\u30ea\u30c3\u30d7\u30dc\u30fc\u30c9\u3078\u30b3\u30d4\u30fc", "clipboard.copied": "\u30b3\u30d4\u30fc\u3057\u307e\u3057\u305f", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\u3000\u3001\u3002\uff0c\uff0e]+", "search.placeholder": "\u691c\u7d22", "search.result.placeholder": "\u691c\u7d22\u30ad\u30fc\u30ef\u30fc\u30c9\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044", "search.result.none": "\u4f55\u3082\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3067\u3057\u305f", "search.result.one": "1\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f", "search.result.other": "#\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f", "search.result.more.one": "\u3053\u306e\u30da\u30fc\u30b8\u5185\u306b\u3082\u30461\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f", "search.result.more.other": "\u3053\u306e\u30da\u30fc\u30b8\u5185\u306b\u3042\u3068#\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f", "search.result.term.missing": "\u691c\u7d22\u306b\u542b\u307e\u308c\u306a\u3044", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.bd0b6b67.min.js"}</script>
    
    
      <script src="../../assets/javascripts/bundle.5413a266.min.js"></script>
      
    
  </body>
</html>