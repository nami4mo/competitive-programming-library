{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Competitive Programming Library \u3053\u306e\u30da\u30fc\u30b8\u306f\u73fe\u5728\u4f5c\u6210\u4e2d\u3067\u3059 \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u751f\u6210\u3055\u308c\u3066\u3044\u308b\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3067\u3059","title":"Competitive Programming Library"},{"location":"#competitive-programming-library","text":"\u3053\u306e\u30da\u30fc\u30b8\u306f\u73fe\u5728\u4f5c\u6210\u4e2d\u3067\u3059 \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u751f\u6210\u3055\u308c\u3066\u3044\u308b\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3067\u3059","title":"Competitive Programming Library"},{"location":"sample/","text":"sample let a = b + 10","title":"sample"},{"location":"sample/#sample","text":"let a = b + 10","title":"sample"},{"location":"rust/bisect/","text":"Bisect Source Code trait Bisect { type Item : Ord + Copy ; fn bisect_left ( & self , x : Self :: Item ) -> usize ; fn bisect_right ( & self , x : Self :: Item ) -> usize ; /* --- count --- */ fn less_eq_cnt ( & self , x : Self :: Item ) -> usize ; // <= x fn less_cnt ( & self , x : Self :: Item ) -> usize ; // < x fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize ; // >= x fn greater_cnt ( & self , x : Self :: Item ) -> usize ; // > x /* --- nearest value --- */ fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; } impl < T : Ord + Copy > Bisect for Vec < T > { type Item = T ; fn bisect_left ( & self , x : Self :: Item ) -> usize { let mut ng = - 1 ; let mut ok = self . len () as i64 ; while ok - ng > 1 { let mid = ( ng + ok ) / 2 ; if x <= self [ mid as usize ] { ok = mid ; } else { ng = mid ; } } ok as usize } fn bisect_right ( & self , x : Self :: Item ) -> usize { let mut ng = - 1 ; let mut ok = self . len () as i64 ; while ok - ng > 1 { let mid = ( ng + ok ) / 2 ; if x < self [ mid as usize ] { ok = mid ; } else { ng = mid ; } } ok as usize } fn less_eq_cnt ( & self , x : Self :: Item ) -> usize { self . bisect_right ( x ) } fn less_cnt ( & self , x : Self :: Item ) -> usize { self . bisect_left ( x ) } fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize { self . len () - self . bisect_left ( x ) } fn greater_cnt ( & self , x : Self :: Item ) -> usize { self . len () - self . bisect_right ( x ) } fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_right ( x ); match ind { 0 => None , _ => Some (( ind - 1 , self [ ind - 1 ])), } } fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_left ( x ); match ind { 0 => None , _ => Some (( ind - 1 , self [ ind - 1 ])), } } fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_left ( x ); if ind == self . len () { None } else { Some (( ind , self [ ind ])) } } fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_right ( x ); if ind == self . len () { None } else { Some (( ind , self [ ind ])) } } } \u4f7f\u3044\u65b9 \u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30b3\u30d4\u30da\u3059\u308c\u3070\u3001 Vec<T: Ord+Copy> \u306b Bisect \u304c\u5b9f\u88c5\u3055\u308c\u308b\u3002 \u4ee5\u4e0b/\u672a\u6e80/\u4ee5\u4e0a/\u3088\u308a\u5927\u304d\u3044 \u500b\u6570\u3092\u6570\u3048\u308b fn less_eq_cnt ( & self , x : Self :: Item ) -> usize ; // <= x fn less_cnt ( & self , x : Self :: Item ) -> usize ; // < x fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize ; // >= x fn greater_cnt ( & self , x : Self :: Item ) -> usize ; // > x // \u4f8b: 10 \u4ee5\u4e0a\u306e\u5024\u306e\u500b\u6570 let cnt = vec . greater_eq_cnt ( 10 ); \u4ee5\u4e0b/\u672a\u6e80/\u4ee5\u4e0a/\u3088\u308a\u5927\u304d\u3044 \u3067 \u6700\u3082\u8fd1\u3044\u5024\uff08index, \u5024\uff09\u3092\u53d6\u5f97\u3059\u308b fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; // \u4f8b: 10\u3088\u308a\u5927\u304d\u3044\u6700\u3082\u8fd1\u3044\u5024\uff08index, \u5024\uff09 let res = vec . greater_nearest ( 10 ); match res { None => (), Some (( ind , val )) => { // } }","title":"Bisect"},{"location":"rust/bisect/#bisect","text":"Source Code trait Bisect { type Item : Ord + Copy ; fn bisect_left ( & self , x : Self :: Item ) -> usize ; fn bisect_right ( & self , x : Self :: Item ) -> usize ; /* --- count --- */ fn less_eq_cnt ( & self , x : Self :: Item ) -> usize ; // <= x fn less_cnt ( & self , x : Self :: Item ) -> usize ; // < x fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize ; // >= x fn greater_cnt ( & self , x : Self :: Item ) -> usize ; // > x /* --- nearest value --- */ fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; } impl < T : Ord + Copy > Bisect for Vec < T > { type Item = T ; fn bisect_left ( & self , x : Self :: Item ) -> usize { let mut ng = - 1 ; let mut ok = self . len () as i64 ; while ok - ng > 1 { let mid = ( ng + ok ) / 2 ; if x <= self [ mid as usize ] { ok = mid ; } else { ng = mid ; } } ok as usize } fn bisect_right ( & self , x : Self :: Item ) -> usize { let mut ng = - 1 ; let mut ok = self . len () as i64 ; while ok - ng > 1 { let mid = ( ng + ok ) / 2 ; if x < self [ mid as usize ] { ok = mid ; } else { ng = mid ; } } ok as usize } fn less_eq_cnt ( & self , x : Self :: Item ) -> usize { self . bisect_right ( x ) } fn less_cnt ( & self , x : Self :: Item ) -> usize { self . bisect_left ( x ) } fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize { self . len () - self . bisect_left ( x ) } fn greater_cnt ( & self , x : Self :: Item ) -> usize { self . len () - self . bisect_right ( x ) } fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_right ( x ); match ind { 0 => None , _ => Some (( ind - 1 , self [ ind - 1 ])), } } fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_left ( x ); match ind { 0 => None , _ => Some (( ind - 1 , self [ ind - 1 ])), } } fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_left ( x ); if ind == self . len () { None } else { Some (( ind , self [ ind ])) } } fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > { let ind = self . bisect_right ( x ); if ind == self . len () { None } else { Some (( ind , self [ ind ])) } } }","title":"Bisect"},{"location":"rust/bisect/#_1","text":"\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30b3\u30d4\u30da\u3059\u308c\u3070\u3001 Vec<T: Ord+Copy> \u306b Bisect \u304c\u5b9f\u88c5\u3055\u308c\u308b\u3002","title":"\u4f7f\u3044\u65b9"},{"location":"rust/bisect/#_2","text":"fn less_eq_cnt ( & self , x : Self :: Item ) -> usize ; // <= x fn less_cnt ( & self , x : Self :: Item ) -> usize ; // < x fn greater_eq_cnt ( & self , x : Self :: Item ) -> usize ; // >= x fn greater_cnt ( & self , x : Self :: Item ) -> usize ; // > x // \u4f8b: 10 \u4ee5\u4e0a\u306e\u5024\u306e\u500b\u6570 let cnt = vec . greater_eq_cnt ( 10 );","title":"\u4ee5\u4e0b/\u672a\u6e80/\u4ee5\u4e0a/\u3088\u308a\u5927\u304d\u3044 \u500b\u6570\u3092\u6570\u3048\u308b"},{"location":"rust/bisect/#index","text":"fn less_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn less_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_eq_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; fn greater_nearest ( & self , x : Self :: Item ) -> Option < ( usize , Self :: Item ) > ; // \u4f8b: 10\u3088\u308a\u5927\u304d\u3044\u6700\u3082\u8fd1\u3044\u5024\uff08index, \u5024\uff09 let res = vec . greater_nearest ( 10 ); match res { None => (), Some (( ind , val )) => { // } }","title":"\u4ee5\u4e0b/\u672a\u6e80/\u4ee5\u4e0a/\u3088\u308a\u5927\u304d\u3044 \u3067 \u6700\u3082\u8fd1\u3044\u5024\uff08index, \u5024\uff09\u3092\u53d6\u5f97\u3059\u308b"},{"location":"rust/convolution/","text":"Convolution (ACL-RS) Source Code pub mod convolution { macro_rules! modulus { ( $($name : ident ), * ) => { $( #[derive(Copy, Clone, Eq, PartialEq)] enum $name {} impl Modulus for $name { const VALUE : u32 = $name as _ ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static :: std :: thread :: LocalKey < :: std :: cell :: RefCell < :: std :: option :: Option < crate :: modint :: ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : :: std :: cell :: RefCell < :: std :: option :: Option < crate :: modint :: ButterflyCache < $name >>> = :: std :: default :: Default :: default (); } & BUTTERFLY_CACHE } } ) * }; } use crate :: { internal_bit , internal_math , modint :: { ButterflyCache , Modulus , RemEuclidU32 , StaticModInt }, }; use std :: { cmp , convert :: { TryFrom , TryInto as _ }, fmt , }; #[allow(clippy::many_single_char_names)] pub fn convolution < M > ( a : & [ StaticModInt < M > ], b : & [ StaticModInt < M > ]) -> Vec < StaticModInt < M >> where M : Modulus , { if a . is_empty () || b . is_empty () { return vec! []; } let ( n , m ) = ( a . len (), b . len ()); if cmp :: min ( n , m ) <= 60 { let ( n , m , a , b ) = if n < m { ( m , n , b , a ) } else { ( n , m , a , b ) }; let mut ans = vec! [ StaticModInt :: new ( 0 ); n + m - 1 ]; for i in 0 .. n { for j in 0 .. m { ans [ i + j ] += a [ i ] * b [ j ]; } } return ans ; } let ( mut a , mut b ) = ( a . to_owned (), b . to_owned ()); let z = 1 << internal_bit :: ceil_pow2 (( n + m - 1 ) as _ ); a . resize ( z , StaticModInt :: raw ( 0 )); butterfly ( & mut a ); b . resize ( z , StaticModInt :: raw ( 0 )); butterfly ( & mut b ); for ( a , b ) in a . iter_mut (). zip ( & b ) { * a *= b ; } butterfly_inv ( & mut a ); a . resize ( n + m - 1 , StaticModInt :: raw ( 0 )); let iz = StaticModInt :: new ( z ). inv (); for a in & mut a { * a *= iz ; } a } pub fn convolution_raw < T , M > ( a : & [ T ], b : & [ T ]) -> Vec < T > where T : RemEuclidU32 + TryFrom < u32 > + Clone , T :: Error : fmt :: Debug , M : Modulus , { let a = a . iter (). cloned (). map ( Into :: into ). collect :: < Vec < _ >> (); let b = b . iter (). cloned (). map ( Into :: into ). collect :: < Vec < _ >> (); convolution :: < M > ( & a , & b ) . into_iter () . map ( | z | { z . val () . try_into () . expect ( \"the numeric type is smaller than the modulus\" ) }) . collect () } #[allow(clippy::many_single_char_names)] pub fn convolution_i64 ( a : & [ i64 ], b : & [ i64 ]) -> Vec < i64 > { const M1 : u64 = 754_974_721 ; // 2^24 const M2 : u64 = 167_772_161 ; // 2^25 const M3 : u64 = 469_762_049 ; // 2^26 const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; const M1M2M3 : u64 = M1M2 . wrapping_mul ( M3 ); modulus ! ( M1 , M2 , M3 ); if a . is_empty () || b . is_empty () { return vec! []; } let ( _ , i1 ) = internal_math :: inv_gcd ( M2M3 as _ , M1 as _ ); let ( _ , i2 ) = internal_math :: inv_gcd ( M1M3 as _ , M2 as _ ); let ( _ , i3 ) = internal_math :: inv_gcd ( M1M2 as _ , M3 as _ ); let c1 = convolution_raw :: < i64 , M1 > ( a , b ); let c2 = convolution_raw :: < i64 , M2 > ( a , b ); let c3 = convolution_raw :: < i64 , M3 > ( a , b ); c1 . into_iter () . zip ( c2 ) . zip ( c3 ) . map ( | (( c1 , c2 ), c3 ) | { const OFFSET : & [ u64 ] = & [ 0 , 0 , M1M2M3 , 2 * M1M2M3 , 3 * M1M2M3 ]; let mut x = [( c1 , i1 , M1 , M2M3 ), ( c2 , i2 , M2 , M1M3 ), ( c3 , i3 , M3 , M1M2 )] . iter () . map ( |& ( c , i , m1 , m2 ) | { c . wrapping_mul ( i ). rem_euclid ( m1 as _ ). wrapping_mul ( m2 as _ ) }) . fold ( 0 , i64 :: wrapping_add ); // B = 2^63, -B <= x, r(real value) < B // (x, x - M, x - 2M, or x - 3M) = r (mod 2B) // r = c1[i] (mod MOD1) // focus on MOD1 // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B) // r = x, // x - M' + (0 or 2B), // x - 2M' + (0, 2B or 4B), // x - 3M' + (0, 2B, 4B or 6B) (without mod!) // (r - x) = 0, (0) // - M' + (0 or 2B), (1) // -2M' + (0 or 2B or 4B), (2) // -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1) // we checked that // ((1) mod MOD1) mod 5 = 2 // ((2) mod MOD1) mod 5 = 3 // ((3) mod MOD1) mod 5 = 4 let mut diff = c1 - internal_math :: safe_mod ( x , M1 as _ ); if diff < 0 { diff += M1 as i64 ; } x = x . wrapping_sub ( OFFSET [ diff . rem_euclid ( 5 ) as usize ] as _ ); x }) . collect () } #[allow(clippy::many_single_char_names)] fn butterfly < M : Modulus > ( a : & mut [ StaticModInt < M > ]) { let n = a . len (); let h = internal_bit :: ceil_pow2 ( n as u32 ); M :: butterfly_cache (). with ( | cache | { let mut cache = cache . borrow_mut (); let ButterflyCache { sum_e , .. } = cache . get_or_insert_with ( prepare ); for ph in 1 ..= h { let w = 1 << ( ph - 1 ); let p = 1 << ( h - ph ); let mut now = StaticModInt :: < M > :: new ( 1 ); for s in 0 .. w { let offset = s << ( h - ph + 1 ); for i in 0 .. p { let l = a [ i + offset ]; let r = a [ i + offset + p ] * now ; a [ i + offset ] = l + r ; a [ i + offset + p ] = l - r ; } now *= sum_e [( ! s ). trailing_zeros () as usize ]; } } }); } #[allow(clippy::many_single_char_names)] fn butterfly_inv < M : Modulus > ( a : & mut [ StaticModInt < M > ]) { let n = a . len (); let h = internal_bit :: ceil_pow2 ( n as u32 ); M :: butterfly_cache (). with ( | cache | { let mut cache = cache . borrow_mut (); let ButterflyCache { sum_ie , .. } = cache . get_or_insert_with ( prepare ); for ph in ( 1 ..= h ). rev () { let w = 1 << ( ph - 1 ); let p = 1 << ( h - ph ); let mut inow = StaticModInt :: < M > :: new ( 1 ); for s in 0 .. w { let offset = s << ( h - ph + 1 ); for i in 0 .. p { let l = a [ i + offset ]; let r = a [ i + offset + p ]; a [ i + offset ] = l + r ; a [ i + offset + p ] = StaticModInt :: new ( M :: VALUE + l . val () - r . val ()) * inow ; } inow *= sum_ie [( ! s ). trailing_zeros () as usize ]; } } }); } fn prepare < M : Modulus > () -> ButterflyCache < M > { let g = StaticModInt :: < M > :: raw ( internal_math :: primitive_root ( M :: VALUE as i32 ) as u32 ); let mut es = [ StaticModInt :: < M > :: raw ( 0 ); 30 ]; // es[i]^(2^(2+i)) == 1 let mut ies = [ StaticModInt :: < M > :: raw ( 0 ); 30 ]; let cnt2 = ( M :: VALUE - 1 ). trailing_zeros () as usize ; let mut e = g . pow ((( M :: VALUE - 1 ) >> cnt2 ). into ()); let mut ie = e . inv (); for i in ( 2 ..= cnt2 ). rev () { es [ i - 2 ] = e ; ies [ i - 2 ] = ie ; e *= e ; ie *= ie ; } let sum_e = es . iter () . scan ( StaticModInt :: new ( 1 ), | acc , e | { * acc *= e ; Some ( * acc ) }) . collect (); let sum_ie = ies . iter () . scan ( StaticModInt :: new ( 1 ), | acc , ie | { * acc *= ie ; Some ( * acc ) }) . collect (); ButterflyCache { sum_e , sum_ie } } #[cfg(test)] mod tests { use crate :: { modint :: { Mod998244353 , Modulus , StaticModInt }, RemEuclidU32 , }; use rand :: { rngs :: ThreadRng , Rng as _ }; use std :: { convert :: { TryFrom , TryInto as _ }, fmt , }; //https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L51-L71 #[test] fn empty () { assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [], & [ 1 , 2 ]). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [ 1 , 2 ], & []). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [ 1 ], & []). is_empty ()); assert! ( super :: convolution_raw :: < i64 , Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution_raw :: < i64 , Mod998244353 > ( & [], & [ 1 , 2 ]). is_empty ()); assert! ( super :: convolution :: < Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution :: < Mod998244353 > ( & [], & [ 1. into (), 2. into ()]). is_empty ()); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L73-L85 #[test] fn mid () { const N : usize = 1234 ; const M : usize = 2345 ; let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < Mod998244353 > ( & mut rng , n ); let ( a , b ) = ( gen_values ( N ), gen_values ( M )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L87-L118 #[test] fn simple_s_mod () { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! ( M1 , M2 ); fn test < M : Modulus > ( rng : & mut ThreadRng ) { let mut gen_values = | n | gen_values :: < Mod998244353 > ( rng , n ); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let ( a , b ) = ( gen_values ( n ), gen_values ( m )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } } let mut rng = rand :: thread_rng (); test :: < M1 > ( & mut rng ); test :: < M2 > ( & mut rng ); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L120-L150 #[test] fn simple_int () { simple_raw :: < i32 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L152-L182 #[test] fn simple_uint () { simple_raw :: < u32 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L184-L214 #[test] fn simple_ll () { simple_raw :: < i64 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L216-L246 #[test] fn simple_ull () { simple_raw :: < u64 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L249-L279 #[test] fn simple_int128 () { simple_raw :: < i128 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L281-L311 #[test] fn simple_uint128 () { simple_raw :: < u128 > (); } fn simple_raw < T > () where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! ( M1 , M2 ); fn test < T , M > ( rng : & mut ThreadRng ) where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { let mut gen_raw_values = | n | gen_raw_values :: < u32 , Mod998244353 > ( rng , n ); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let ( a , b ) = ( gen_raw_values ( n ), gen_raw_values ( m )); assert_eq! ( conv_raw_naive :: < _ , M > ( & a , & b ), super :: convolution_raw :: < _ , M > ( & a , & b ), ); } } let mut rng = rand :: thread_rng (); test :: < T , M1 > ( & mut rng ); test :: < T , M2 > ( & mut rng ); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L315-L329 #[test] fn conv_ll () { let mut rng = rand :: thread_rng (); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let mut gen = | n : usize | -> Vec < _ > { ( 0 .. n ). map ( | _ | rng . gen_range ( - 500_000 , 500_000 )). collect () }; let ( a , b ) = ( gen ( n ), gen ( m )); assert_eq! ( conv_i64_naive ( & a , & b ), super :: convolution_i64 ( & a , & b )); } } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L331-L356 #[test] fn conv_ll_bound () { const M1 : u64 = 754_974_721 ; // 2^24 const M2 : u64 = 167_772_161 ; // 2^25 const M3 : u64 = 469_762_049 ; // 2^26 const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; modulus ! ( M1 , M2 , M3 ); for i in - 1000 ..= 1000 { let a = vec! [ 0 u64 . wrapping_sub ( M1M2 + M1M3 + M2M3 ) as i64 + i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } for i in 0 .. 1000 { let a = vec! [ i64 :: min_value () + i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } for i in 0 .. 1000 { let a = vec! [ i64 :: max_value () - i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L358-L371 #[test] fn conv_641 () { const M : u32 = 641 ; modulus ! ( M ); let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < M > ( & mut rng , n ); let ( a , b ) = ( gen_values ( 64 ), gen_values ( 65 )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L373-L386 #[test] fn conv_18433 () { const M : u32 = 18433 ; modulus ! ( M ); let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < M > ( & mut rng , n ); let ( a , b ) = ( gen_values ( 1024 ), gen_values ( 1025 )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } #[allow(clippy::many_single_char_names)] fn conv_naive < M : Modulus > ( a : & [ StaticModInt < M > ], b : & [ StaticModInt < M > ], ) -> Vec < StaticModInt < M >> { let ( n , m ) = ( a . len (), b . len ()); let mut c = vec! [ StaticModInt :: raw ( 0 ); n + m - 1 ]; for ( i , j ) in ( 0 .. n ). flat_map ( | i | ( 0 .. m ). map ( move | j | ( i , j ))) { c [ i + j ] += a [ i ] * b [ j ]; } c } fn conv_raw_naive < T , M > ( a : & [ T ], b : & [ T ]) -> Vec < T > where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { conv_naive :: < M > ( & a . iter (). copied (). map ( Into :: into ). collect :: < Vec < _ >> (), & b . iter (). copied (). map ( Into :: into ). collect :: < Vec < _ >> (), ) . into_iter () . map ( | x | x . val (). try_into (). unwrap ()) . collect () } #[allow(clippy::many_single_char_names)] fn conv_i64_naive ( a : & [ i64 ], b : & [ i64 ]) -> Vec < i64 > { let ( n , m ) = ( a . len (), b . len ()); let mut c = vec! [ 0 ; n + m - 1 ]; for ( i , j ) in ( 0 .. n ). flat_map ( | i | ( 0 .. m ). map ( move | j | ( i , j ))) { c [ i + j ] += a [ i ] * b [ j ]; } c } fn gen_values < M : Modulus > ( rng : & mut ThreadRng , n : usize ) -> Vec < StaticModInt < M >> { ( 0 .. n ). map ( | _ | rng . gen_range ( 0 , M :: VALUE ). into ()). collect () } fn gen_raw_values < T , M > ( rng : & mut ThreadRng , n : usize ) -> Vec < T > where T : TryFrom < u32 > , T :: Error : fmt :: Debug , M : Modulus , { ( 0 .. n ) . map ( | _ | rng . gen_range ( 0 , M :: VALUE ). try_into (). unwrap ()) . collect () } } } pub mod internal_bit { // Skipped: // // - `bsf` = `__builtin_ctz`: is equivalent to `{integer}::trailing_zeros` #[allow(dead_code)] pub ( crate ) fn ceil_pow2 ( n : u32 ) -> u32 { 32 - n . saturating_sub ( 1 ). leading_zeros () } #[cfg(test)] mod tests { #[test] fn ceil_pow2 () { // https://github.com/atcoder/ac-library/blob/2088c8e2431c3f4d29a2cfabc6529fe0a0586c48/test/unittest/bit_test.cpp assert_eq! ( 0 , super :: ceil_pow2 ( 0 )); assert_eq! ( 0 , super :: ceil_pow2 ( 1 )); assert_eq! ( 1 , super :: ceil_pow2 ( 2 )); assert_eq! ( 2 , super :: ceil_pow2 ( 3 )); assert_eq! ( 2 , super :: ceil_pow2 ( 4 )); assert_eq! ( 3 , super :: ceil_pow2 ( 5 )); assert_eq! ( 3 , super :: ceil_pow2 ( 6 )); assert_eq! ( 3 , super :: ceil_pow2 ( 7 )); assert_eq! ( 3 , super :: ceil_pow2 ( 8 )); assert_eq! ( 4 , super :: ceil_pow2 ( 9 )); assert_eq! ( 30 , super :: ceil_pow2 ( 1 << 30 )); assert_eq! ( 31 , super :: ceil_pow2 (( 1 << 30 ) + 1 )); assert_eq! ( 32 , super :: ceil_pow2 ( u32 :: max_value ())); } } } pub mod internal_math { // remove this after dependencies has been added #![allow(dead_code)] use std :: mem :: swap ; /// # Arguments /// * `m` `1 <= m` /// /// # Returns /// x mod m /* const */ pub ( crate ) fn safe_mod ( mut x : i64 , m : i64 ) -> i64 { x %= m ; if x < 0 { x += m ; } x } /// Fast modular by barrett reduction /// Reference: https://en.wikipedia.org/wiki/Barrett_reduction /// NOTE: reconsider after Ice Lake pub ( crate ) struct Barrett { pub ( crate ) _m : u32 , pub ( crate ) im : u64 , } impl Barrett { /// # Arguments /// * `m` `1 <= m` /// (Note: `m <= 2^31` should also hold, which is undocumented in the original library. /// See the [pull reqeust commment](https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484661007) /// for more details.) pub ( crate ) fn new ( m : u32 ) -> Barrett { Barrett { _m : m , im : ( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 ), } } /// # Returns /// `m` pub ( crate ) fn umod ( & self ) -> u32 { self . _m } /// # Parameters /// * `a` `0 <= a < m` /// * `b` `0 <= b < m` /// /// # Returns /// a * b % m #[allow(clippy::many_single_char_names)] pub ( crate ) fn mul ( & self , a : u32 , b : u32 ) -> u32 { mul_mod ( a , b , self . _m , self . im ) } } /// Calculates `a * b % m`. /// /// * `a` `0 <= a < m` /// * `b` `0 <= b < m` /// * `m` `1 <= m <= 2^31` /// * `im` = ceil(2^64 / `m`) #[allow(clippy::many_single_char_names)] pub ( crate ) fn mul_mod ( a : u32 , b : u32 , m : u32 , im : u64 ) -> u32 { // [1] m = 1 // a = b = im = 0, so okay // [2] m >= 2 // im = ceil(2^64 / m) // -> im * m = 2^64 + r (0 <= r < m) // let z = a*b = c*m + d (0 <= c, d < m) // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2 // ((ab * im) >> 64) == c or c + 1 let mut z = a as u64 ; z *= b as u64 ; let x = ((( z as u128 ) * ( im as u128 )) >> 64 ) as u64 ; let mut v = z . wrapping_sub ( x . wrapping_mul ( m as u64 )) as u32 ; if m <= v { v = v . wrapping_add ( m ); } v } /// # Parameters /// * `n` `0 <= n` /// * `m` `1 <= m` /// /// # Returns /// `(x ** n) % m` /* const */ #[allow(clippy::many_single_char_names)] pub ( crate ) fn pow_mod ( x : i64 , mut n : i64 , m : i32 ) -> i64 { if m == 1 { return 0 ; } let _m = m as u32 ; let mut r : u64 = 1 ; let mut y : u64 = safe_mod ( x , m as i64 ) as u64 ; while n != 0 { if ( n & 1 ) > 0 { r = ( r * y ) % ( _m as u64 ); } y = ( y * y ) % ( _m as u64 ); n >>= 1 ; } r as i64 } /// Reference: /// M. Forisek and J. Jancina, /// Fast Primality Testing for Integers That Fit into a Machine Word /// /// # Parameters /// * `n` `0 <= n` /* const */ pub ( crate ) fn is_prime ( n : i32 ) -> bool { let n = n as i64 ; match n { _ if n <= 1 => return false , 2 | 7 | 61 => return true , _ if n % 2 == 0 => return false , _ => {} } let mut d = n - 1 ; while d % 2 == 0 { d /= 2 ; } for & a in & [ 2 , 7 , 61 ] { let mut t = d ; let mut y = pow_mod ( a , t , n as i32 ); while t != n - 1 && y != 1 && y != n - 1 { y = y * y % n ; t <<= 1 ; } if y != n - 1 && t % 2 == 0 { return false ; } } true } // omitted // template <int n> constexpr bool is_prime = is_prime_constexpr(n); /// # Parameters /// * `b` `1 <= b` /// /// # Returns /// (g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g /* const */ #[allow(clippy::many_single_char_names)] pub ( crate ) fn inv_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { let a = safe_mod ( a , b ); if a == 0 { return ( b , 0 ); } // Contracts: // [1] s - m0 * a = 0 (mod b) // [2] t - m1 * a = 0 (mod b) // [3] s * |m1| + t * |m0| <= b let mut s = b ; let mut t = a ; let mut m0 = 0 ; let mut m1 = 1 ; while t != 0 { let u = s / t ; s -= t * u ; m0 -= m1 * u ; // |m1 * u| <= |m1| * s <= b // [3]: // (s - t * u) * |m1| + t * |m0 - m1 * u| // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u) // = s * |m1| + t * |m0| <= b swap ( & mut s , & mut t ); swap ( & mut m0 , & mut m1 ); } // by [3]: |m0| <= b/g // by g != b: |m0| < b/g if m0 < 0 { m0 += b / s ; } ( s , m0 ) } /// Compile time (currently not) primitive root /// @param m must be prime /// @return primitive root (and minimum in now) /* const */ pub ( crate ) fn primitive_root ( m : i32 ) -> i32 { match m { 2 => return 1 , 167_772_161 => return 3 , 469_762_049 => return 3 , 754_974_721 => return 11 , 998_244_353 => return 3 , _ => {} } let mut divs = [ 0 ; 20 ]; divs [ 0 ] = 2 ; let mut cnt = 1 ; let mut x = ( m - 1 ) / 2 ; while x % 2 == 0 { x /= 2 ; } for i in ( 3 .. std :: i32 :: MAX ). step_by ( 2 ) { if i as i64 * i as i64 > x as i64 { break ; } if x % i == 0 { divs [ cnt ] = i ; cnt += 1 ; while x % i == 0 { x /= i ; } } } if x > 1 { divs [ cnt ] = x ; cnt += 1 ; } let mut g = 2 ; loop { if ( 0 .. cnt ). all ( | i | pow_mod ( g , (( m - 1 ) / divs [ i ]) as i64 , m ) != 1 ) { break g as i32 ; } g += 1 ; } } // omitted // template <int m> constexpr int primitive_root = primitive_root_constexpr(m); #[cfg(test)] mod tests { #![allow(clippy::unreadable_literal)] #![allow(clippy::cognitive_complexity)] use crate :: internal_math :: { inv_gcd , is_prime , pow_mod , primitive_root , safe_mod , Barrett }; use std :: collections :: HashSet ; #[test] fn test_safe_mod () { assert_eq! ( safe_mod ( 0 , 3 ), 0 ); assert_eq! ( safe_mod ( 1 , 3 ), 1 ); assert_eq! ( safe_mod ( 2 , 3 ), 2 ); assert_eq! ( safe_mod ( 3 , 3 ), 0 ); assert_eq! ( safe_mod ( 4 , 3 ), 1 ); assert_eq! ( safe_mod ( 5 , 3 ), 2 ); assert_eq! ( safe_mod ( 73 , 11 ), 7 ); assert_eq! ( safe_mod ( 2306249155046129918 , 6620319213327 ), 1374210749525 ); assert_eq! ( safe_mod ( - 1 , 3 ), 2 ); assert_eq! ( safe_mod ( - 2 , 3 ), 1 ); assert_eq! ( safe_mod ( - 3 , 3 ), 0 ); assert_eq! ( safe_mod ( - 4 , 3 ), 2 ); assert_eq! ( safe_mod ( - 5 , 3 ), 1 ); assert_eq! ( safe_mod ( - 7170500492396019511 , 777567337 ), 333221848 ); } #[test] fn test_barrett () { let b = Barrett :: new ( 7 ); assert_eq! ( b . umod (), 7 ); assert_eq! ( b . mul ( 2 , 3 ), 6 ); assert_eq! ( b . mul ( 4 , 6 ), 3 ); assert_eq! ( b . mul ( 5 , 0 ), 0 ); let b = Barrett :: new ( 998244353 ); assert_eq! ( b . umod (), 998244353 ); assert_eq! ( b . mul ( 2 , 3 ), 6 ); assert_eq! ( b . mul ( 3141592 , 653589 ), 919583920 ); assert_eq! ( b . mul ( 323846264 , 338327950 ), 568012980 ); // make `z - x * self._m as u64` overflow. // Thanks @koba-e964 (at https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484932161) let b = Barrett :: new ( 2147483647 ); assert_eq! ( b . umod (), 2147483647 ); assert_eq! ( b . mul ( 1073741824 , 2147483645 ), 2147483646 ); } #[test] fn test_pow_mod () { assert_eq! ( pow_mod ( 0 , 0 , 1 ), 0 ); assert_eq! ( pow_mod ( 0 , 0 , 3 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , 723 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 0 , 1 , 1 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 3 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 723 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 998244353 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , i32 :: max_value ()), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 3 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 723 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 998244353 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), i32 :: max_value ()), 0 ); assert_eq! ( pow_mod ( 1 , 0 , 1 ), 0 ); assert_eq! ( pow_mod ( 1 , 0 , 3 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , 723 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 1 ), 0 ); assert_eq! ( pow_mod ( 1 , 1 , 3 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 723 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 3 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 723 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 1 ), 0 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 3 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 723 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 3 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 723 ), 640 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 998244353 ), 683296792 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 2 , 3 , 1_000_000_007 ), 8 ); assert_eq! ( pow_mod ( 5 , 7 , 1_000_000_007 ), 78125 ); assert_eq! ( pow_mod ( 123 , 456 , 1_000_000_007 ), 565291922 ); } #[test] fn test_is_prime () { assert! ( ! is_prime ( 0 )); assert! ( ! is_prime ( 1 )); assert! ( is_prime ( 2 )); assert! ( is_prime ( 3 )); assert! ( ! is_prime ( 4 )); assert! ( is_prime ( 5 )); assert! ( ! is_prime ( 6 )); assert! ( is_prime ( 7 )); assert! ( ! is_prime ( 8 )); assert! ( ! is_prime ( 9 )); // assert!(is_prime(57)); assert! ( ! is_prime ( 57 )); assert! ( ! is_prime ( 58 )); assert! ( is_prime ( 59 )); assert! ( ! is_prime ( 60 )); assert! ( is_prime ( 61 )); assert! ( ! is_prime ( 62 )); assert! ( ! is_prime ( 701928443 )); assert! ( is_prime ( 998244353 )); assert! ( ! is_prime ( 1_000_000_000 )); assert! ( is_prime ( 1_000_000_007 )); assert! ( is_prime ( i32 :: max_value ())); } #[test] fn test_is_prime_sieve () { let n = 1_000_000 ; let mut prime = vec! [ true ; n ]; prime [ 0 ] = false ; prime [ 1 ] = false ; for i in 0 .. n { assert_eq! ( prime [ i ], is_prime ( i as i32 )); if prime [ i ] { for j in ( 2 * i .. n ). step_by ( i ) { prime [ j ] = false ; } } } } #[test] fn test_inv_gcd () { for & ( a , b , g ) in & [ ( 0 , 1 , 1 ), ( 0 , 4 , 4 ), ( 0 , 7 , 7 ), ( 2 , 3 , 1 ), ( - 2 , 3 , 1 ), ( 4 , 6 , 2 ), ( - 4 , 6 , 2 ), ( 13 , 23 , 1 ), ( 57 , 81 , 3 ), ( 12345 , 67890 , 15 ), ( - 3141592 * 6535 , 3141592 * 8979 , 3141592 ), ( i64 :: max_value (), i64 :: max_value (), i64 :: max_value ()), ( i64 :: min_value (), i64 :: max_value (), 1 ), ] { let ( g_ , x ) = inv_gcd ( a , b ); assert_eq! ( g , g_ ); let b_ = b as i128 ; assert_eq! ((( x as i128 * a as i128 ) % b_ + b_ ) % b_ , g as i128 % b_ ); } } #[test] fn test_primitive_root () { for & p in & [ 2 , 3 , 5 , 7 , 233 , 200003 , 998244353 , 1_000_000_007 , i32 :: max_value (), ] { assert! ( is_prime ( p )); let g = primitive_root ( p ); if p != 2 { assert_ne! ( g , 1 ); } let q = p - 1 ; for i in ( 2 .. i32 :: max_value ()). take_while ( | i | i * i <= q ) { if q % i != 0 { break ; } for & r in & [ i , q / i ] { assert_ne! ( pow_mod ( g as i64 , r as i64 , p ), 1 ); } } assert_eq! ( pow_mod ( g as i64 , q as i64 , p ), 1 ); if p < 1_000_000 { assert_eq! ( ( 0 .. p - 1 ) . scan ( 1 , | i , _ | { * i = * i * g % p ; Some ( * i ) }) . collect :: < HashSet < _ >> () . len () as i32 , p - 1 ); } } } } } pub mod modint { //! Structs that treat the modular arithmetic. //! //! For most of the problems, It is sufficient to use [`ModInt1000000007`] or [`ModInt998244353`], which can be used as follows. //! //! ``` //! use ac_library_rs::ModInt1000000007 as Mint; // rename to whatever you want //! use proconio::{input, source::once::OnceSource}; //! //! input! { //! from OnceSource::from(\"1000000006 2\\n\"), //! a: Mint, //! b: Mint, //! } //! //! println!(\"{}\", a + b); // `1` //! ``` //! //! If the modulus is not fixed, you can use [`ModInt`] as follows. //! //! ``` //! use ac_library_rs::ModInt as Mint; // rename to whatever you want //! use proconio::{input, source::once::OnceSource}; //! //! input! { //! from OnceSource::from(\"3 3 7\\n\"), //! a: u32, //! b: u32, //! m: u32, //! } //! //! Mint::set_modulus(m); //! let a = Mint::new(a); //! let b = Mint::new(b); //! //! println!(\"{}\", a * b); // `2` //! ``` //! //! # Major changes from the original ACL //! //! - Converted the struct names to PascalCase. //! - Renamed `mod` \u2192 `modulus`. //! - Moduli are `u32`, not `i32`. //! - Each `Id` does not have a identifier number. Instead, they explicitly own `&'static LocalKey<RefCell<Barrett>>`. //! - The type of the argument of `pow` is `u64`, not `i64`. //! - Modints implement `FromStr` and `Display`. Modints in the original ACL don't have `operator<<` or `operator>>`. //! //! [`ModInt1000000007`]: ./type.ModInt1000000007.html //! [`ModInt998244353`]: ./type.ModInt998244353.html //! [`ModInt`]: ./type.ModInt.html use crate :: internal_math ; use std :: { cell :: RefCell , convert :: { Infallible , TryInto as _ }, fmt , hash :: { Hash , Hasher }, iter :: { Product , Sum }, marker :: PhantomData , ops :: { Add , AddAssign , Div , DivAssign , Mul , MulAssign , Neg , Sub , SubAssign }, str :: FromStr , sync :: atomic :: { self , AtomicU32 , AtomicU64 }, thread :: LocalKey , }; pub type ModInt1000000007 = StaticModInt < Mod1000000007 > ; pub type ModInt998244353 = StaticModInt < Mod998244353 > ; pub type ModInt = DynamicModInt < DefaultId > ; /// Represents _\u2124/m\u2124_ where _m_ is a constant value. /// /// Corresponds to `atcoder::static_modint` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt1000000007 as Mint; /// use proconio::{input, source::once::OnceSource}; /// /// input! { /// from OnceSource::from(\"1000000006 2\\n\"), /// a: Mint, /// b: Mint, /// } /// /// println!(\"{}\", a + b); // `1` /// ``` #[derive(Copy, Clone, Eq, PartialEq)] #[repr(transparent)] pub struct StaticModInt < M > { val : u32 , phantom : PhantomData < fn () -> M > , } impl < M : Modulus > StaticModInt < M > { /// Returns the modulus, which is [`<M as Modulus>::VALUE`]. /// /// Corresponds to `atcoder::static_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt1000000007 as Mint; /// /// assert_eq!(1_000_000_007, Mint::modulus()); /// ``` /// /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE #[inline(always)] pub fn modulus () -> u32 { M :: VALUE } /// Creates a new `StaticModInt`. /// /// Takes [any primitive integer]. /// /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL. /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] pub fn new < T : RemEuclidU32 > ( val : T ) -> Self { Self :: raw ( val . rem_euclid_u32 ( M :: VALUE )) } /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::static_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// See [`ModIntBase::raw`] for more more details. /// /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw #[inline] pub fn raw ( val : u32 ) -> Self { Self { val , phantom : PhantomData , } } /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` in the original ACL. #[inline] pub fn val ( self ) -> u32 { self . val } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::static_modint::pow` in the original ACL. #[inline] pub fn pow ( self , n : u64 ) -> Self { < Self as ModIntBase > :: pow ( self , n ) } /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::static_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. #[inline] pub fn inv ( self ) -> Self { if M :: HINT_VALUE_IS_PRIME { if self . val () == 0 { panic! ( \"attempt to divide by zero\" ); } debug_assert! ( internal_math :: is_prime ( M :: VALUE . try_into (). unwrap ()), \"{} is not a prime number\" , M :: VALUE , ); self . pow (( M :: VALUE - 2 ). into ()) } else { Self :: inv_for_non_prime_modulus ( self ) } } } /// These methods are implemented for the struct. /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`. impl < M : Modulus > ModIntBase for StaticModInt < M > { #[inline(always)] fn modulus () -> u32 { Self :: modulus () } #[inline] fn raw ( val : u32 ) -> Self { Self :: raw ( val ) } #[inline] fn val ( self ) -> u32 { self . val () } #[inline] fn inv ( self ) -> Self { self . inv () } } /// Represents a modulus. /// /// # Example /// /// ``` /// macro_rules! modulus { /// ($($name:ident($value:expr, $is_prime:expr)),*) => { /// $( /// #[derive(Copy, Clone, Eq, PartialEq)] /// enum $name {} /// /// impl ac_library_rs::modint::Modulus for $name { /// const VALUE: u32 = $value; /// const HINT_VALUE_IS_PRIME: bool = $is_prime; /// /// fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library_rs::modint::ButterflyCache<Self>>>> { /// thread_local! { /// static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library_rs::modint::ButterflyCache<$name>>> = ::std::default::Default::default(); /// } /// &BUTTERFLY_CACHE /// } /// } /// )* /// }; /// } /// /// use ac_library_rs::StaticModInt; /// /// modulus!(Mod101(101, true), Mod103(103, true)); /// /// type Z101 = StaticModInt<Mod101>; /// type Z103 = StaticModInt<Mod103>; /// /// assert_eq!(Z101::new(101), Z101::new(0)); /// assert_eq!(Z103::new(103), Z103::new(0)); /// ``` pub trait Modulus : ' static + Copy + Eq { const VALUE : u32 ; const HINT_VALUE_IS_PRIME : bool ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> ; } /// Represents _1000000007_. #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum Mod1000000007 {} impl Modulus for Mod1000000007 { const VALUE : u32 = 1_000_000_007 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod1000000007 >>> = RefCell :: default (); } & BUTTERFLY_CACHE } } /// Represents _998244353_. #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum Mod998244353 {} impl Modulus for Mod998244353 { const VALUE : u32 = 998_244_353 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod998244353 >>> = RefCell :: default (); } & BUTTERFLY_CACHE } } /// Cache for butterfly operations. pub struct ButterflyCache < M > { pub ( crate ) sum_e : Vec < StaticModInt < M >> , pub ( crate ) sum_ie : Vec < StaticModInt < M >> , } /// Represents _\u2124/m\u2124_ where _m_ is a dynamic value. /// /// Corresponds to `atcoder::dynamic_modint` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// use proconio::{input, source::once::OnceSource}; /// /// input! { /// from OnceSource::from(\"3 3 7\\n\"), /// a: u32, /// b: u32, /// m: u32, /// } /// /// Mint::set_modulus(m); /// let a = Mint::new(a); /// let b = Mint::new(b); /// /// println!(\"{}\", a * b); // `2` /// ``` #[derive(Copy, Clone, Eq, PartialEq)] #[repr(transparent)] pub struct DynamicModInt < I > { val : u32 , phantom : PhantomData < fn () -> I > , } impl < I : Id > DynamicModInt < I > { /// Returns the modulus. /// /// Corresponds to `atcoder::dynamic_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// /// assert_eq!(998_244_353, Mint::modulus()); // default modulus /// ``` #[inline] pub fn modulus () -> u32 { I :: companion_barrett (). umod () } /// Sets a modulus. /// /// Corresponds to `atcoder::dynamic_modint::set_mod` in the original ACL. /// /// # Constraints /// /// - This function must be called earlier than any other operation of `Self`. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// /// Mint::set_modulus(7); /// assert_eq!(7, Mint::modulus()); /// ``` #[inline] pub fn set_modulus ( modulus : u32 ) { if modulus == 0 { panic! ( \"the modulus must not be 0\" ); } I :: companion_barrett (). update ( modulus ); } /// Creates a new `DynamicModInt`. /// /// Takes [any primitive integer]. /// /// Corresponds to the constructor of `atcoder::dynamic_modint` in the original ACL. /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] pub fn new < T : RemEuclidU32 > ( val : T ) -> Self { < Self as ModIntBase > :: new ( val ) } /// Constructs a `DynamicModInt` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::dynamic_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// See [`ModIntBase::raw`] for more more details. /// /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw #[inline] pub fn raw ( val : u32 ) -> Self { Self { val , phantom : PhantomData , } } /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` in the original ACL. #[inline] pub fn val ( self ) -> u32 { self . val } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::dynamic_modint::pow` in the original ACL. #[inline] pub fn pow ( self , n : u64 ) -> Self { < Self as ModIntBase > :: pow ( self , n ) } /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::dynamic_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. #[inline] pub fn inv ( self ) -> Self { Self :: inv_for_non_prime_modulus ( self ) } } /// These methods are implemented for the struct. /// You don't need to `use` `ModIntBase` to call methods of `DynamicModInt`. impl < I : Id > ModIntBase for DynamicModInt < I > { #[inline] fn modulus () -> u32 { Self :: modulus () } #[inline] fn raw ( val : u32 ) -> Self { Self :: raw ( val ) } #[inline] fn val ( self ) -> u32 { self . val () } #[inline] fn inv ( self ) -> Self { self . inv () } } pub trait Id : ' static + Copy + Eq { fn companion_barrett () -> & ' static Barrett ; } #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum DefaultId {} impl Id for DefaultId { fn companion_barrett () -> & ' static Barrett { static BARRETT : Barrett = Barrett :: default (); & BARRETT } } /// Pair of _m_ and _ceil(2\u2076\u2074/m)_. pub struct Barrett { m : AtomicU32 , im : AtomicU64 , } impl Barrett { /// Creates a new `Barrett`. #[inline] pub const fn new ( m : u32 ) -> Self { Self { m : AtomicU32 :: new ( m ), im : AtomicU64 :: new (( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 )), } } #[inline] const fn default () -> Self { Self :: new ( 998_244_353 ) } #[inline] fn update ( & self , m : u32 ) { let im = ( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 ); self . m . store ( m , atomic :: Ordering :: SeqCst ); self . im . store ( im , atomic :: Ordering :: SeqCst ); } #[inline] fn umod ( & self ) -> u32 { self . m . load ( atomic :: Ordering :: SeqCst ) } #[inline] fn mul ( & self , a : u32 , b : u32 ) -> u32 { let m = self . m . load ( atomic :: Ordering :: SeqCst ); let im = self . im . load ( atomic :: Ordering :: SeqCst ); internal_math :: mul_mod ( a , b , m , im ) } } impl Default for Barrett { #[inline] fn default () -> Self { Self :: default () } } /// A trait for [`StaticModInt`] and [`DynamicModInt`]. /// /// Corresponds to `atcoder::internal::modint_base` in the original ACL. /// /// [`StaticModInt`]: ../struct.StaticModInt.html /// [`DynamicModInt`]: ../struct.DynamicModInt.html pub trait ModIntBase : Default + FromStr + From < i8 > + From < i16 > + From < i32 > + From < i64 > + From < i128 > + From < isize > + From < u8 > + From < u16 > + From < u32 > + From < u64 > + From < u128 > + From < usize > + Copy + Eq + Hash + fmt :: Display + fmt :: Debug + Neg < Output = Self > + Add < Output = Self > + Sub < Output = Self > + Mul < Output = Self > + Div < Output = Self > + AddAssign + SubAssign + MulAssign + DivAssign { /// Returns the modulus. /// /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _: u32 = Z::modulus(); /// } /// ``` fn modulus () -> u32 ; /// Constructs a `Self` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// **Note that all operations assume that inner values are smaller than the modulus.** /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined. /// /// ```should_panic /// use ac_library_rs::ModInt1000000007 as Mint; /// /// let x = Mint::raw(1_000_000_007); /// let y = x + x; /// assert_eq!(0, y.val()); /// ``` /// /// ```text /// thread 'main' panicked at 'assertion failed: `(left == right)` /// left: `0`, /// right: `1000000007`', src/modint.rs:8:1 /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace /// ``` /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() -> Z { /// debug_assert!(Z::modulus() >= 100); /// /// let mut acc = Z::new(0); /// for i in 0..100 { /// if i % 3 == 0 { /// // I know `i` is smaller than the modulus! /// acc += Z::raw(i); /// } /// } /// acc /// } /// ``` fn raw ( val : u32 ) -> Self ; /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>(x: Z) { /// let _: u32 = x.val(); /// } /// ``` fn val ( self ) -> u32 ; /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>(x: Z) { /// let _: Z = x.inv(); /// } /// ``` fn inv ( self ) -> Self ; /// Creates a new `Self`. /// /// Takes [any primitive integer]. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _ = Z::new(1u32); /// let _ = Z::new(1usize); /// let _ = Z::new(-1i64); /// } /// ``` /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] fn new < T : RemEuclidU32 > ( val : T ) -> Self { Self :: raw ( val . rem_euclid_u32 ( Self :: modulus ())) } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _: Z = Z::new(2).pow(3); /// } /// ``` #[inline] fn pow ( self , mut n : u64 ) -> Self { let mut x = self ; let mut r = Self :: raw ( 1 ); while n > 0 { if n & 1 == 1 { r *= x ; } x *= x ; n >>= 1 ; } r } } /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`. pub trait RemEuclidU32 { /// Calculates `self` _mod_ `modulus` losslessly. fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 ; } macro_rules! impl_rem_euclid_u32_for_small_signed { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { ( self as i64 ). rem_euclid ( i64 :: from ( modulus )) as _ } } ) * } } impl_rem_euclid_u32_for_small_signed ! ( i8 , i16 , i32 , i64 , isize ); impl RemEuclidU32 for i128 { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { self . rem_euclid ( i128 :: from ( modulus )) as _ } } macro_rules! impl_rem_euclid_u32_for_small_unsigned { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { self as u32 % modulus } } ) * } } macro_rules! impl_rem_euclid_u32_for_large_unsigned { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { ( self % ( modulus as $ty )) as _ } } ) * } } impl_rem_euclid_u32_for_small_unsigned ! ( u8 , u16 , u32 ); impl_rem_euclid_u32_for_large_unsigned ! ( u64 , u128 ); #[cfg(target_pointer_width = \"32\" )] impl_rem_euclid_u32_for_small_unsigned ! ( usize ); #[cfg(target_pointer_width = \"64\" )] impl_rem_euclid_u32_for_large_unsigned ! ( usize ); trait InternalImplementations : ModIntBase { #[inline] fn inv_for_non_prime_modulus ( this : Self ) -> Self { let ( gcd , x ) = internal_math :: inv_gcd ( this . val (). into (), Self :: modulus (). into ()); if gcd != 1 { panic! ( \"the multiplicative inverse does not exist\" ); } Self :: new ( x ) } #[inline] fn default_impl () -> Self { Self :: raw ( 0 ) } #[inline] fn from_str_impl ( s : & str ) -> Result < Self , Infallible > { Ok ( s . parse :: < i64 > () . map ( Self :: new ) . unwrap_or_else ( | _ | todo! ( \"parsing as an arbitrary precision integer?\" ))) } #[inline] fn hash_impl ( this : & Self , state : & mut impl Hasher ) { this . val (). hash ( state ) } #[inline] fn display_impl ( this : & Self , f : & mut fmt :: Formatter ) -> fmt :: Result { fmt :: Display :: fmt ( & this . val (), f ) } #[inline] fn debug_impl ( this : & Self , f : & mut fmt :: Formatter ) -> fmt :: Result { fmt :: Debug :: fmt ( & this . val (), f ) } #[inline] fn neg_impl ( this : Self ) -> Self { Self :: sub_impl ( Self :: raw ( 0 ), this ) } #[inline] fn add_impl ( lhs : Self , rhs : Self ) -> Self { let modulus = Self :: modulus (); let mut val = lhs . val () + rhs . val (); if val >= modulus { val -= modulus ; } Self :: raw ( val ) } #[inline] fn sub_impl ( lhs : Self , rhs : Self ) -> Self { let modulus = Self :: modulus (); let mut val = lhs . val (). wrapping_sub ( rhs . val ()); if val >= modulus { val = val . wrapping_add ( modulus ) } Self :: raw ( val ) } fn mul_impl ( lhs : Self , rhs : Self ) -> Self ; #[inline] fn div_impl ( lhs : Self , rhs : Self ) -> Self { Self :: mul_impl ( lhs , rhs . inv ()) } } impl < M : Modulus > InternalImplementations for StaticModInt < M > { #[inline] fn mul_impl ( lhs : Self , rhs : Self ) -> Self { Self :: raw (( u64 :: from ( lhs . val ()) * u64 :: from ( rhs . val ()) % u64 :: from ( M :: VALUE )) as u32 ) } } impl < I : Id > InternalImplementations for DynamicModInt < I > { #[inline] fn mul_impl ( lhs : Self , rhs : Self ) -> Self { Self :: raw ( I :: companion_barrett (). mul ( lhs . val , rhs . val )) } } macro_rules! impl_basic_traits { () => {}; ( impl < $generic_param : ident : $generic_param_bound : tt > _ for $self : ty ; $($rest : tt ) * ) => { impl < $generic_param : $generic_param_bound > Default for $self { #[inline] fn default () -> Self { Self :: default_impl () } } impl < $generic_param : $generic_param_bound > FromStr for $self { type Err = Infallible ; #[inline] fn from_str ( s : & str ) -> Result < Self , Infallible > { Self :: from_str_impl ( s ) } } impl < $generic_param : $generic_param_bound , V : RemEuclidU32 > From < V > for $self { #[inline] fn from ( from : V ) -> Self { Self :: new ( from ) } } #[allow(clippy::derive_hash_xor_eq)] impl < $generic_param : $generic_param_bound > Hash for $self { #[inline] fn hash < H : Hasher > ( & self , state : & mut H ) { Self :: hash_impl ( self , state ) } } impl < $generic_param : $generic_param_bound > fmt :: Display for $self { #[inline] fn fmt ( & self , f : & mut fmt :: Formatter <' _ > ) -> fmt :: Result { Self :: display_impl ( self , f ) } } impl < $generic_param : $generic_param_bound > fmt :: Debug for $self { #[inline] fn fmt ( & self , f : & mut fmt :: Formatter <' _ > ) -> fmt :: Result { Self :: debug_impl ( self , f ) } } impl < $generic_param : $generic_param_bound > Neg for $self { type Output = $self ; #[inline] fn neg ( self ) -> $self { Self :: neg_impl ( self ) } } impl < $generic_param : $generic_param_bound > Neg for &' _ $self { type Output = $self ; #[inline] fn neg ( self ) -> $self { < $self > :: neg_impl ( * self ) } } impl_basic_traits ! ( $($rest ) * ); }; } impl_basic_traits ! { impl < M : Modulus > _ for StaticModInt < M > ; impl < I : Id > _ for DynamicModInt < I > ; } macro_rules! impl_bin_ops { () => {}; ( for < $($generic_param : ident : $generic_param_bound : tt ), *> < $lhs_ty : ty > ~ < $rhs_ty : ty > -> $output : ty { { $lhs_body : expr } ~ { $rhs_body : expr } } $($rest : tt ) * ) => { impl < $($generic_param : $generic_param_bound ), *> Add < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn add ( self , rhs : $rhs_ty ) -> $output { < $output > :: add_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Sub < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn sub ( self , rhs : $rhs_ty ) -> $output { < $output > :: sub_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Mul < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn mul ( self , rhs : $rhs_ty ) -> $output { < $output > :: mul_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Div < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn div ( self , rhs : $rhs_ty ) -> $output { < $output > :: div_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl_bin_ops ! ( $($rest ) * ); }; } macro_rules! impl_assign_ops { () => {}; ( for < $($generic_param : ident : $generic_param_bound : tt ), *> < $lhs_ty : ty > ~= < $rhs_ty : ty > { _ ~= { $rhs_body : expr } } $($rest : tt ) * ) => { impl < $($generic_param : $generic_param_bound ), *> AddAssign < $rhs_ty > for $lhs_ty { #[inline] fn add_assign ( & mut self , rhs : $rhs_ty ) { * self = * self + apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> SubAssign < $rhs_ty > for $lhs_ty { #[inline] fn sub_assign ( & mut self , rhs : $rhs_ty ) { * self = * self - apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> MulAssign < $rhs_ty > for $lhs_ty { #[inline] fn mul_assign ( & mut self , rhs : $rhs_ty ) { * self = * self * apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> DivAssign < $rhs_ty > for $lhs_ty { #[inline] fn div_assign ( & mut self , rhs : $rhs_ty ) { * self = * self / apply ( $rhs_body , rhs ); } } impl_assign_ops ! ( $($rest ) * ); }; } #[inline] fn apply < F : FnOnce ( X ) -> O , X , O > ( f : F , x : X ) -> O { f ( x ) } impl_bin_ops ! { for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { | x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&' _ StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { |& x | x } } for < M : Modulus > <&' _ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { | x | x } } for < M : Modulus > <&' _ StaticModInt < M > > ~ <&' _ StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { |& x | x } } for < I : Id > < DynamicModInt < I > > ~ < DynamicModInt < I > > -> DynamicModInt < I > { { | x | x } ~ { | x | x } } for < I : Id > < DynamicModInt < I > > ~ <&' _ DynamicModInt < I >> -> DynamicModInt < I > { { | x | x } ~ { |& x | x } } for < I : Id > <&' _ DynamicModInt < I >> ~ < DynamicModInt < I > > -> DynamicModInt < I > { { |& x | x } ~ { | x | x } } for < I : Id > <&' _ DynamicModInt < I >> ~ <&' _ DynamicModInt < I >> -> DynamicModInt < I > { { |& x | x } ~ { |& x | x } } for < M : Modulus , T : RemEuclidU32 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > { { | x | x } ~ { StaticModInt :: < M > :: new } } for < I : Id , T : RemEuclidU32 > < DynamicModInt < I > > ~ < T > -> DynamicModInt < I > { { | x | x } ~ { DynamicModInt :: < I > :: new } } } impl_assign_ops ! { for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > { _ ~= { | x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&' _ StaticModInt < M > > { _ ~= { |& x | x } } for < I : Id > < DynamicModInt < I >> ~= < DynamicModInt < I > > { _ ~= { | x | x } } for < I : Id > < DynamicModInt < I >> ~= <&' _ DynamicModInt < I >> { _ ~= { |& x | x } } for < M : Modulus , T : RemEuclidU32 > < StaticModInt < M > > ~= < T > { _ ~= { StaticModInt :: < M > :: new } } for < I : Id , T : RemEuclidU32 > < DynamicModInt < I >> ~= < T > { _ ~= { DynamicModInt :: < I > :: new } } } macro_rules! impl_folding { () => {}; ( impl < $generic_param : ident : $generic_param_bound : tt > $trait : ident < _ > for $self : ty { fn $method : ident ( _ ) -> _ { _ ( $unit : expr , $op : expr ) } } $($rest : tt ) * ) => { impl < $generic_param : $generic_param_bound > $trait < Self > for $self { #[inline] fn $method < S > ( iter : S ) -> Self where S : Iterator < Item = Self > , { iter . fold ( $unit , $op ) } } impl <' a , $generic_param : $generic_param_bound > $trait <&' a Self > for $self { #[inline] fn $method < S > ( iter : S ) -> Self where S : Iterator < Item = &' a Self > , { iter . fold ( $unit , $op ) } } impl_folding ! ( $($rest ) * ); }; } impl_folding ! { impl < M : Modulus > Sum < _ > for StaticModInt < M > { fn sum ( _ ) -> _ { _ ( Self :: raw ( 0 ), Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > { fn product ( _ ) -> _ { _ ( Self :: raw ( 1 ), Mul :: mul ) } } impl < I : Id > Sum < _ > for DynamicModInt < I > { fn sum ( _ ) -> _ { _ ( Self :: raw ( 0 ), Add :: add ) } } impl < I : Id > Product < _ > for DynamicModInt < I > { fn product ( _ ) -> _ { _ ( Self :: raw ( 1 ), Mul :: mul ) } } } #[cfg(test)] mod tests { use crate :: modint :: ModInt1000000007 ; #[test] fn static_modint_new () { assert_eq! ( 0 , ModInt1000000007 :: new ( 0 u32 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 u32 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 u32 ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 u64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 u64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 u64 ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 usize ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 usize ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 usize ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 i64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 i64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 i64 ). val ); assert_eq! ( 1_000_000_006 , ModInt1000000007 :: new ( - 1 i64 ). val ); } #[test] fn static_modint_add () { fn add ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) + ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 2 , add ( 1 , 1 )); assert_eq! ( 1 , add ( 1_000_000_006 , 2 )); } #[test] fn static_modint_sub () { fn sub ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) - ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 1 , sub ( 2 , 1 )); assert_eq! ( 1_000_000_006 , sub ( 0 , 1 )); } #[test] fn static_modint_mul () { fn mul ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) * ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 1 , mul ( 1 , 1 )); assert_eq! ( 4 , mul ( 2 , 2 )); assert_eq! ( 999_999_937 , mul ( 100_000 , 100_000 )); } #[test] fn static_modint_prime_div () { fn div ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) / ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 0 , div ( 0 , 1 )); assert_eq! ( 1 , div ( 1 , 1 )); assert_eq! ( 1 , div ( 2 , 2 )); assert_eq! ( 23_809_524 , div ( 1 , 42 )); } #[test] fn static_modint_sum () { fn sum ( values : & [ i64 ]) -> ModInt1000000007 { values . iter (). copied (). map ( ModInt1000000007 :: new ). sum () } assert_eq! ( ModInt1000000007 :: new ( - 3 ), sum ( & [ - 1 , 2 , - 3 , 4 , - 5 ])); } #[test] fn static_modint_product () { fn product ( values : & [ i64 ]) -> ModInt1000000007 { values . iter (). copied (). map ( ModInt1000000007 :: new ). product () } assert_eq! ( ModInt1000000007 :: new ( - 120 ), product ( & [ - 1 , 2 , - 3 , 4 , - 5 ])); } #[test] fn static_modint_binop_coercion () { let f = ModInt1000000007 :: new ; let a = 10_293_812_ usize ; let b = 9_083_240_982_ usize ; assert_eq! ( f ( a ) + f ( b ), f ( a ) + b ); assert_eq! ( f ( a ) - f ( b ), f ( a ) - b ); assert_eq! ( f ( a ) * f ( b ), f ( a ) * b ); assert_eq! ( f ( a ) / f ( b ), f ( a ) / b ); } #[test] fn static_modint_assign_coercion () { let f = ModInt1000000007 :: new ; let a = f ( 10_293_812_ usize ); let b = 9_083_240_982_ usize ; let expected = ((( a + b ) * b ) - b ) / b ; let mut c = a ; c += b ; c *= b ; c -= b ; c /= b ; assert_eq! ( expected , c ); } } } use convolution :: * ; use modint :: * ; \u4f7f\u3044\u65b9 ModInt \u4e0d\u4f7f\u7528 let cl = convolution_raw :: < i64 , Mod998244353 > ( & al , & bl ); \u305d\u308c\u305e\u308c\u306e\u578b\u306f Vec<i64> ModInt \u4f7f\u7528 let cml = convolution :: < Mod998244353 > ( & aml , & bml ); \u305d\u308c\u305e\u308c\u306e\u578b\u306f Vec<StaticModInt<Mod998244353>> \u4f8b\u984c ACL-F : \u7573\u307f\u8fbc\u307f\u306e\u7d50\u679c\u3092 Mod \u3067\u6c42\u3081\u308b\u3060\u3051 fn solve1 () { input ! { n : usize , m : usize , al : [ i64 ; n ], bl : [ i64 ; m ], } // ModInt \u4e0d\u4f7f\u7528 let cl = convolution_raw :: < i64 , Mod998244353 > ( & al , & bl ); for c in cl { print! ( \"{} \" , c ); } println! (); } fn solve2 () { input ! { n : usize , m : usize , al : [ i64 ; n ], bl : [ i64 ; m ], } // ModInt \u4f7f\u7528 let aml = al . iter (). map ( |& x | ModInt998244353 :: new ( x )). collect_vec (); let bml = bl . iter (). map ( |& x | ModInt998244353 :: new ( x )). collect_vec (); let cml = convolution :: < Mod998244353 > ( & aml , & bml ); for c in cml { print! ( \"{} \" , c ); } println! (); }","title":"Convolution (ACL-RS)"},{"location":"rust/convolution/#convolution-acl-rs","text":"Source Code pub mod convolution { macro_rules! modulus { ( $($name : ident ), * ) => { $( #[derive(Copy, Clone, Eq, PartialEq)] enum $name {} impl Modulus for $name { const VALUE : u32 = $name as _ ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static :: std :: thread :: LocalKey < :: std :: cell :: RefCell < :: std :: option :: Option < crate :: modint :: ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : :: std :: cell :: RefCell < :: std :: option :: Option < crate :: modint :: ButterflyCache < $name >>> = :: std :: default :: Default :: default (); } & BUTTERFLY_CACHE } } ) * }; } use crate :: { internal_bit , internal_math , modint :: { ButterflyCache , Modulus , RemEuclidU32 , StaticModInt }, }; use std :: { cmp , convert :: { TryFrom , TryInto as _ }, fmt , }; #[allow(clippy::many_single_char_names)] pub fn convolution < M > ( a : & [ StaticModInt < M > ], b : & [ StaticModInt < M > ]) -> Vec < StaticModInt < M >> where M : Modulus , { if a . is_empty () || b . is_empty () { return vec! []; } let ( n , m ) = ( a . len (), b . len ()); if cmp :: min ( n , m ) <= 60 { let ( n , m , a , b ) = if n < m { ( m , n , b , a ) } else { ( n , m , a , b ) }; let mut ans = vec! [ StaticModInt :: new ( 0 ); n + m - 1 ]; for i in 0 .. n { for j in 0 .. m { ans [ i + j ] += a [ i ] * b [ j ]; } } return ans ; } let ( mut a , mut b ) = ( a . to_owned (), b . to_owned ()); let z = 1 << internal_bit :: ceil_pow2 (( n + m - 1 ) as _ ); a . resize ( z , StaticModInt :: raw ( 0 )); butterfly ( & mut a ); b . resize ( z , StaticModInt :: raw ( 0 )); butterfly ( & mut b ); for ( a , b ) in a . iter_mut (). zip ( & b ) { * a *= b ; } butterfly_inv ( & mut a ); a . resize ( n + m - 1 , StaticModInt :: raw ( 0 )); let iz = StaticModInt :: new ( z ). inv (); for a in & mut a { * a *= iz ; } a } pub fn convolution_raw < T , M > ( a : & [ T ], b : & [ T ]) -> Vec < T > where T : RemEuclidU32 + TryFrom < u32 > + Clone , T :: Error : fmt :: Debug , M : Modulus , { let a = a . iter (). cloned (). map ( Into :: into ). collect :: < Vec < _ >> (); let b = b . iter (). cloned (). map ( Into :: into ). collect :: < Vec < _ >> (); convolution :: < M > ( & a , & b ) . into_iter () . map ( | z | { z . val () . try_into () . expect ( \"the numeric type is smaller than the modulus\" ) }) . collect () } #[allow(clippy::many_single_char_names)] pub fn convolution_i64 ( a : & [ i64 ], b : & [ i64 ]) -> Vec < i64 > { const M1 : u64 = 754_974_721 ; // 2^24 const M2 : u64 = 167_772_161 ; // 2^25 const M3 : u64 = 469_762_049 ; // 2^26 const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; const M1M2M3 : u64 = M1M2 . wrapping_mul ( M3 ); modulus ! ( M1 , M2 , M3 ); if a . is_empty () || b . is_empty () { return vec! []; } let ( _ , i1 ) = internal_math :: inv_gcd ( M2M3 as _ , M1 as _ ); let ( _ , i2 ) = internal_math :: inv_gcd ( M1M3 as _ , M2 as _ ); let ( _ , i3 ) = internal_math :: inv_gcd ( M1M2 as _ , M3 as _ ); let c1 = convolution_raw :: < i64 , M1 > ( a , b ); let c2 = convolution_raw :: < i64 , M2 > ( a , b ); let c3 = convolution_raw :: < i64 , M3 > ( a , b ); c1 . into_iter () . zip ( c2 ) . zip ( c3 ) . map ( | (( c1 , c2 ), c3 ) | { const OFFSET : & [ u64 ] = & [ 0 , 0 , M1M2M3 , 2 * M1M2M3 , 3 * M1M2M3 ]; let mut x = [( c1 , i1 , M1 , M2M3 ), ( c2 , i2 , M2 , M1M3 ), ( c3 , i3 , M3 , M1M2 )] . iter () . map ( |& ( c , i , m1 , m2 ) | { c . wrapping_mul ( i ). rem_euclid ( m1 as _ ). wrapping_mul ( m2 as _ ) }) . fold ( 0 , i64 :: wrapping_add ); // B = 2^63, -B <= x, r(real value) < B // (x, x - M, x - 2M, or x - 3M) = r (mod 2B) // r = c1[i] (mod MOD1) // focus on MOD1 // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B) // r = x, // x - M' + (0 or 2B), // x - 2M' + (0, 2B or 4B), // x - 3M' + (0, 2B, 4B or 6B) (without mod!) // (r - x) = 0, (0) // - M' + (0 or 2B), (1) // -2M' + (0 or 2B or 4B), (2) // -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1) // we checked that // ((1) mod MOD1) mod 5 = 2 // ((2) mod MOD1) mod 5 = 3 // ((3) mod MOD1) mod 5 = 4 let mut diff = c1 - internal_math :: safe_mod ( x , M1 as _ ); if diff < 0 { diff += M1 as i64 ; } x = x . wrapping_sub ( OFFSET [ diff . rem_euclid ( 5 ) as usize ] as _ ); x }) . collect () } #[allow(clippy::many_single_char_names)] fn butterfly < M : Modulus > ( a : & mut [ StaticModInt < M > ]) { let n = a . len (); let h = internal_bit :: ceil_pow2 ( n as u32 ); M :: butterfly_cache (). with ( | cache | { let mut cache = cache . borrow_mut (); let ButterflyCache { sum_e , .. } = cache . get_or_insert_with ( prepare ); for ph in 1 ..= h { let w = 1 << ( ph - 1 ); let p = 1 << ( h - ph ); let mut now = StaticModInt :: < M > :: new ( 1 ); for s in 0 .. w { let offset = s << ( h - ph + 1 ); for i in 0 .. p { let l = a [ i + offset ]; let r = a [ i + offset + p ] * now ; a [ i + offset ] = l + r ; a [ i + offset + p ] = l - r ; } now *= sum_e [( ! s ). trailing_zeros () as usize ]; } } }); } #[allow(clippy::many_single_char_names)] fn butterfly_inv < M : Modulus > ( a : & mut [ StaticModInt < M > ]) { let n = a . len (); let h = internal_bit :: ceil_pow2 ( n as u32 ); M :: butterfly_cache (). with ( | cache | { let mut cache = cache . borrow_mut (); let ButterflyCache { sum_ie , .. } = cache . get_or_insert_with ( prepare ); for ph in ( 1 ..= h ). rev () { let w = 1 << ( ph - 1 ); let p = 1 << ( h - ph ); let mut inow = StaticModInt :: < M > :: new ( 1 ); for s in 0 .. w { let offset = s << ( h - ph + 1 ); for i in 0 .. p { let l = a [ i + offset ]; let r = a [ i + offset + p ]; a [ i + offset ] = l + r ; a [ i + offset + p ] = StaticModInt :: new ( M :: VALUE + l . val () - r . val ()) * inow ; } inow *= sum_ie [( ! s ). trailing_zeros () as usize ]; } } }); } fn prepare < M : Modulus > () -> ButterflyCache < M > { let g = StaticModInt :: < M > :: raw ( internal_math :: primitive_root ( M :: VALUE as i32 ) as u32 ); let mut es = [ StaticModInt :: < M > :: raw ( 0 ); 30 ]; // es[i]^(2^(2+i)) == 1 let mut ies = [ StaticModInt :: < M > :: raw ( 0 ); 30 ]; let cnt2 = ( M :: VALUE - 1 ). trailing_zeros () as usize ; let mut e = g . pow ((( M :: VALUE - 1 ) >> cnt2 ). into ()); let mut ie = e . inv (); for i in ( 2 ..= cnt2 ). rev () { es [ i - 2 ] = e ; ies [ i - 2 ] = ie ; e *= e ; ie *= ie ; } let sum_e = es . iter () . scan ( StaticModInt :: new ( 1 ), | acc , e | { * acc *= e ; Some ( * acc ) }) . collect (); let sum_ie = ies . iter () . scan ( StaticModInt :: new ( 1 ), | acc , ie | { * acc *= ie ; Some ( * acc ) }) . collect (); ButterflyCache { sum_e , sum_ie } } #[cfg(test)] mod tests { use crate :: { modint :: { Mod998244353 , Modulus , StaticModInt }, RemEuclidU32 , }; use rand :: { rngs :: ThreadRng , Rng as _ }; use std :: { convert :: { TryFrom , TryInto as _ }, fmt , }; //https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L51-L71 #[test] fn empty () { assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [], & [ 1 , 2 ]). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [ 1 , 2 ], & []). is_empty ()); assert! ( super :: convolution_raw :: < i32 , Mod998244353 > ( & [ 1 ], & []). is_empty ()); assert! ( super :: convolution_raw :: < i64 , Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution_raw :: < i64 , Mod998244353 > ( & [], & [ 1 , 2 ]). is_empty ()); assert! ( super :: convolution :: < Mod998244353 > ( & [], & []). is_empty ()); assert! ( super :: convolution :: < Mod998244353 > ( & [], & [ 1. into (), 2. into ()]). is_empty ()); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L73-L85 #[test] fn mid () { const N : usize = 1234 ; const M : usize = 2345 ; let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < Mod998244353 > ( & mut rng , n ); let ( a , b ) = ( gen_values ( N ), gen_values ( M )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L87-L118 #[test] fn simple_s_mod () { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! ( M1 , M2 ); fn test < M : Modulus > ( rng : & mut ThreadRng ) { let mut gen_values = | n | gen_values :: < Mod998244353 > ( rng , n ); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let ( a , b ) = ( gen_values ( n ), gen_values ( m )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } } let mut rng = rand :: thread_rng (); test :: < M1 > ( & mut rng ); test :: < M2 > ( & mut rng ); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L120-L150 #[test] fn simple_int () { simple_raw :: < i32 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L152-L182 #[test] fn simple_uint () { simple_raw :: < u32 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L184-L214 #[test] fn simple_ll () { simple_raw :: < i64 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L216-L246 #[test] fn simple_ull () { simple_raw :: < u64 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L249-L279 #[test] fn simple_int128 () { simple_raw :: < i128 > (); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L281-L311 #[test] fn simple_uint128 () { simple_raw :: < u128 > (); } fn simple_raw < T > () where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! ( M1 , M2 ); fn test < T , M > ( rng : & mut ThreadRng ) where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { let mut gen_raw_values = | n | gen_raw_values :: < u32 , Mod998244353 > ( rng , n ); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let ( a , b ) = ( gen_raw_values ( n ), gen_raw_values ( m )); assert_eq! ( conv_raw_naive :: < _ , M > ( & a , & b ), super :: convolution_raw :: < _ , M > ( & a , & b ), ); } } let mut rng = rand :: thread_rng (); test :: < T , M1 > ( & mut rng ); test :: < T , M2 > ( & mut rng ); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L315-L329 #[test] fn conv_ll () { let mut rng = rand :: thread_rng (); for ( n , m ) in ( 1 .. 20 ). flat_map ( | i | ( 1 .. 20 ). map ( move | j | ( i , j ))) { let mut gen = | n : usize | -> Vec < _ > { ( 0 .. n ). map ( | _ | rng . gen_range ( - 500_000 , 500_000 )). collect () }; let ( a , b ) = ( gen ( n ), gen ( m )); assert_eq! ( conv_i64_naive ( & a , & b ), super :: convolution_i64 ( & a , & b )); } } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L331-L356 #[test] fn conv_ll_bound () { const M1 : u64 = 754_974_721 ; // 2^24 const M2 : u64 = 167_772_161 ; // 2^25 const M3 : u64 = 469_762_049 ; // 2^26 const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; modulus ! ( M1 , M2 , M3 ); for i in - 1000 ..= 1000 { let a = vec! [ 0 u64 . wrapping_sub ( M1M2 + M1M3 + M2M3 ) as i64 + i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } for i in 0 .. 1000 { let a = vec! [ i64 :: min_value () + i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } for i in 0 .. 1000 { let a = vec! [ i64 :: max_value () - i ]; let b = vec! [ 1 ]; assert_eq! ( a , super :: convolution_i64 ( & a , & b )); } } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L358-L371 #[test] fn conv_641 () { const M : u32 = 641 ; modulus ! ( M ); let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < M > ( & mut rng , n ); let ( a , b ) = ( gen_values ( 64 ), gen_values ( 65 )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } // https://github.com/atcoder/ac-library/blob/8250de484ae0ab597391db58040a602e0dc1a419/test/unittest/convolution_test.cpp#L373-L386 #[test] fn conv_18433 () { const M : u32 = 18433 ; modulus ! ( M ); let mut rng = rand :: thread_rng (); let mut gen_values = | n | gen_values :: < M > ( & mut rng , n ); let ( a , b ) = ( gen_values ( 1024 ), gen_values ( 1025 )); assert_eq! ( conv_naive ( & a , & b ), super :: convolution ( & a , & b )); } #[allow(clippy::many_single_char_names)] fn conv_naive < M : Modulus > ( a : & [ StaticModInt < M > ], b : & [ StaticModInt < M > ], ) -> Vec < StaticModInt < M >> { let ( n , m ) = ( a . len (), b . len ()); let mut c = vec! [ StaticModInt :: raw ( 0 ); n + m - 1 ]; for ( i , j ) in ( 0 .. n ). flat_map ( | i | ( 0 .. m ). map ( move | j | ( i , j ))) { c [ i + j ] += a [ i ] * b [ j ]; } c } fn conv_raw_naive < T , M > ( a : & [ T ], b : & [ T ]) -> Vec < T > where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { conv_naive :: < M > ( & a . iter (). copied (). map ( Into :: into ). collect :: < Vec < _ >> (), & b . iter (). copied (). map ( Into :: into ). collect :: < Vec < _ >> (), ) . into_iter () . map ( | x | x . val (). try_into (). unwrap ()) . collect () } #[allow(clippy::many_single_char_names)] fn conv_i64_naive ( a : & [ i64 ], b : & [ i64 ]) -> Vec < i64 > { let ( n , m ) = ( a . len (), b . len ()); let mut c = vec! [ 0 ; n + m - 1 ]; for ( i , j ) in ( 0 .. n ). flat_map ( | i | ( 0 .. m ). map ( move | j | ( i , j ))) { c [ i + j ] += a [ i ] * b [ j ]; } c } fn gen_values < M : Modulus > ( rng : & mut ThreadRng , n : usize ) -> Vec < StaticModInt < M >> { ( 0 .. n ). map ( | _ | rng . gen_range ( 0 , M :: VALUE ). into ()). collect () } fn gen_raw_values < T , M > ( rng : & mut ThreadRng , n : usize ) -> Vec < T > where T : TryFrom < u32 > , T :: Error : fmt :: Debug , M : Modulus , { ( 0 .. n ) . map ( | _ | rng . gen_range ( 0 , M :: VALUE ). try_into (). unwrap ()) . collect () } } } pub mod internal_bit { // Skipped: // // - `bsf` = `__builtin_ctz`: is equivalent to `{integer}::trailing_zeros` #[allow(dead_code)] pub ( crate ) fn ceil_pow2 ( n : u32 ) -> u32 { 32 - n . saturating_sub ( 1 ). leading_zeros () } #[cfg(test)] mod tests { #[test] fn ceil_pow2 () { // https://github.com/atcoder/ac-library/blob/2088c8e2431c3f4d29a2cfabc6529fe0a0586c48/test/unittest/bit_test.cpp assert_eq! ( 0 , super :: ceil_pow2 ( 0 )); assert_eq! ( 0 , super :: ceil_pow2 ( 1 )); assert_eq! ( 1 , super :: ceil_pow2 ( 2 )); assert_eq! ( 2 , super :: ceil_pow2 ( 3 )); assert_eq! ( 2 , super :: ceil_pow2 ( 4 )); assert_eq! ( 3 , super :: ceil_pow2 ( 5 )); assert_eq! ( 3 , super :: ceil_pow2 ( 6 )); assert_eq! ( 3 , super :: ceil_pow2 ( 7 )); assert_eq! ( 3 , super :: ceil_pow2 ( 8 )); assert_eq! ( 4 , super :: ceil_pow2 ( 9 )); assert_eq! ( 30 , super :: ceil_pow2 ( 1 << 30 )); assert_eq! ( 31 , super :: ceil_pow2 (( 1 << 30 ) + 1 )); assert_eq! ( 32 , super :: ceil_pow2 ( u32 :: max_value ())); } } } pub mod internal_math { // remove this after dependencies has been added #![allow(dead_code)] use std :: mem :: swap ; /// # Arguments /// * `m` `1 <= m` /// /// # Returns /// x mod m /* const */ pub ( crate ) fn safe_mod ( mut x : i64 , m : i64 ) -> i64 { x %= m ; if x < 0 { x += m ; } x } /// Fast modular by barrett reduction /// Reference: https://en.wikipedia.org/wiki/Barrett_reduction /// NOTE: reconsider after Ice Lake pub ( crate ) struct Barrett { pub ( crate ) _m : u32 , pub ( crate ) im : u64 , } impl Barrett { /// # Arguments /// * `m` `1 <= m` /// (Note: `m <= 2^31` should also hold, which is undocumented in the original library. /// See the [pull reqeust commment](https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484661007) /// for more details.) pub ( crate ) fn new ( m : u32 ) -> Barrett { Barrett { _m : m , im : ( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 ), } } /// # Returns /// `m` pub ( crate ) fn umod ( & self ) -> u32 { self . _m } /// # Parameters /// * `a` `0 <= a < m` /// * `b` `0 <= b < m` /// /// # Returns /// a * b % m #[allow(clippy::many_single_char_names)] pub ( crate ) fn mul ( & self , a : u32 , b : u32 ) -> u32 { mul_mod ( a , b , self . _m , self . im ) } } /// Calculates `a * b % m`. /// /// * `a` `0 <= a < m` /// * `b` `0 <= b < m` /// * `m` `1 <= m <= 2^31` /// * `im` = ceil(2^64 / `m`) #[allow(clippy::many_single_char_names)] pub ( crate ) fn mul_mod ( a : u32 , b : u32 , m : u32 , im : u64 ) -> u32 { // [1] m = 1 // a = b = im = 0, so okay // [2] m >= 2 // im = ceil(2^64 / m) // -> im * m = 2^64 + r (0 <= r < m) // let z = a*b = c*m + d (0 <= c, d < m) // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2 // ((ab * im) >> 64) == c or c + 1 let mut z = a as u64 ; z *= b as u64 ; let x = ((( z as u128 ) * ( im as u128 )) >> 64 ) as u64 ; let mut v = z . wrapping_sub ( x . wrapping_mul ( m as u64 )) as u32 ; if m <= v { v = v . wrapping_add ( m ); } v } /// # Parameters /// * `n` `0 <= n` /// * `m` `1 <= m` /// /// # Returns /// `(x ** n) % m` /* const */ #[allow(clippy::many_single_char_names)] pub ( crate ) fn pow_mod ( x : i64 , mut n : i64 , m : i32 ) -> i64 { if m == 1 { return 0 ; } let _m = m as u32 ; let mut r : u64 = 1 ; let mut y : u64 = safe_mod ( x , m as i64 ) as u64 ; while n != 0 { if ( n & 1 ) > 0 { r = ( r * y ) % ( _m as u64 ); } y = ( y * y ) % ( _m as u64 ); n >>= 1 ; } r as i64 } /// Reference: /// M. Forisek and J. Jancina, /// Fast Primality Testing for Integers That Fit into a Machine Word /// /// # Parameters /// * `n` `0 <= n` /* const */ pub ( crate ) fn is_prime ( n : i32 ) -> bool { let n = n as i64 ; match n { _ if n <= 1 => return false , 2 | 7 | 61 => return true , _ if n % 2 == 0 => return false , _ => {} } let mut d = n - 1 ; while d % 2 == 0 { d /= 2 ; } for & a in & [ 2 , 7 , 61 ] { let mut t = d ; let mut y = pow_mod ( a , t , n as i32 ); while t != n - 1 && y != 1 && y != n - 1 { y = y * y % n ; t <<= 1 ; } if y != n - 1 && t % 2 == 0 { return false ; } } true } // omitted // template <int n> constexpr bool is_prime = is_prime_constexpr(n); /// # Parameters /// * `b` `1 <= b` /// /// # Returns /// (g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g /* const */ #[allow(clippy::many_single_char_names)] pub ( crate ) fn inv_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { let a = safe_mod ( a , b ); if a == 0 { return ( b , 0 ); } // Contracts: // [1] s - m0 * a = 0 (mod b) // [2] t - m1 * a = 0 (mod b) // [3] s * |m1| + t * |m0| <= b let mut s = b ; let mut t = a ; let mut m0 = 0 ; let mut m1 = 1 ; while t != 0 { let u = s / t ; s -= t * u ; m0 -= m1 * u ; // |m1 * u| <= |m1| * s <= b // [3]: // (s - t * u) * |m1| + t * |m0 - m1 * u| // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u) // = s * |m1| + t * |m0| <= b swap ( & mut s , & mut t ); swap ( & mut m0 , & mut m1 ); } // by [3]: |m0| <= b/g // by g != b: |m0| < b/g if m0 < 0 { m0 += b / s ; } ( s , m0 ) } /// Compile time (currently not) primitive root /// @param m must be prime /// @return primitive root (and minimum in now) /* const */ pub ( crate ) fn primitive_root ( m : i32 ) -> i32 { match m { 2 => return 1 , 167_772_161 => return 3 , 469_762_049 => return 3 , 754_974_721 => return 11 , 998_244_353 => return 3 , _ => {} } let mut divs = [ 0 ; 20 ]; divs [ 0 ] = 2 ; let mut cnt = 1 ; let mut x = ( m - 1 ) / 2 ; while x % 2 == 0 { x /= 2 ; } for i in ( 3 .. std :: i32 :: MAX ). step_by ( 2 ) { if i as i64 * i as i64 > x as i64 { break ; } if x % i == 0 { divs [ cnt ] = i ; cnt += 1 ; while x % i == 0 { x /= i ; } } } if x > 1 { divs [ cnt ] = x ; cnt += 1 ; } let mut g = 2 ; loop { if ( 0 .. cnt ). all ( | i | pow_mod ( g , (( m - 1 ) / divs [ i ]) as i64 , m ) != 1 ) { break g as i32 ; } g += 1 ; } } // omitted // template <int m> constexpr int primitive_root = primitive_root_constexpr(m); #[cfg(test)] mod tests { #![allow(clippy::unreadable_literal)] #![allow(clippy::cognitive_complexity)] use crate :: internal_math :: { inv_gcd , is_prime , pow_mod , primitive_root , safe_mod , Barrett }; use std :: collections :: HashSet ; #[test] fn test_safe_mod () { assert_eq! ( safe_mod ( 0 , 3 ), 0 ); assert_eq! ( safe_mod ( 1 , 3 ), 1 ); assert_eq! ( safe_mod ( 2 , 3 ), 2 ); assert_eq! ( safe_mod ( 3 , 3 ), 0 ); assert_eq! ( safe_mod ( 4 , 3 ), 1 ); assert_eq! ( safe_mod ( 5 , 3 ), 2 ); assert_eq! ( safe_mod ( 73 , 11 ), 7 ); assert_eq! ( safe_mod ( 2306249155046129918 , 6620319213327 ), 1374210749525 ); assert_eq! ( safe_mod ( - 1 , 3 ), 2 ); assert_eq! ( safe_mod ( - 2 , 3 ), 1 ); assert_eq! ( safe_mod ( - 3 , 3 ), 0 ); assert_eq! ( safe_mod ( - 4 , 3 ), 2 ); assert_eq! ( safe_mod ( - 5 , 3 ), 1 ); assert_eq! ( safe_mod ( - 7170500492396019511 , 777567337 ), 333221848 ); } #[test] fn test_barrett () { let b = Barrett :: new ( 7 ); assert_eq! ( b . umod (), 7 ); assert_eq! ( b . mul ( 2 , 3 ), 6 ); assert_eq! ( b . mul ( 4 , 6 ), 3 ); assert_eq! ( b . mul ( 5 , 0 ), 0 ); let b = Barrett :: new ( 998244353 ); assert_eq! ( b . umod (), 998244353 ); assert_eq! ( b . mul ( 2 , 3 ), 6 ); assert_eq! ( b . mul ( 3141592 , 653589 ), 919583920 ); assert_eq! ( b . mul ( 323846264 , 338327950 ), 568012980 ); // make `z - x * self._m as u64` overflow. // Thanks @koba-e964 (at https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484932161) let b = Barrett :: new ( 2147483647 ); assert_eq! ( b . umod (), 2147483647 ); assert_eq! ( b . mul ( 1073741824 , 2147483645 ), 2147483646 ); } #[test] fn test_pow_mod () { assert_eq! ( pow_mod ( 0 , 0 , 1 ), 0 ); assert_eq! ( pow_mod ( 0 , 0 , 3 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , 723 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 0 , 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 0 , 1 , 1 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 3 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 723 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , 998244353 ), 0 ); assert_eq! ( pow_mod ( 0 , 1 , i32 :: max_value ()), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 3 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 723 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), 998244353 ), 0 ); assert_eq! ( pow_mod ( 0 , i64 :: max_value (), i32 :: max_value ()), 0 ); assert_eq! ( pow_mod ( 1 , 0 , 1 ), 0 ); assert_eq! ( pow_mod ( 1 , 0 , 3 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , 723 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 1 ), 0 ); assert_eq! ( pow_mod ( 1 , 1 , 3 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 723 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , 1 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 3 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 723 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), 998244353 ), 1 ); assert_eq! ( pow_mod ( 1 , i64 :: max_value (), i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 1 ), 0 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 3 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 723 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , 998244353 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), 0 , i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 1 ), 0 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 3 ), 1 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 723 ), 640 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), 998244353 ), 683296792 ); assert_eq! ( pow_mod ( i64 :: max_value (), i64 :: max_value (), i32 :: max_value ()), 1 ); assert_eq! ( pow_mod ( 2 , 3 , 1_000_000_007 ), 8 ); assert_eq! ( pow_mod ( 5 , 7 , 1_000_000_007 ), 78125 ); assert_eq! ( pow_mod ( 123 , 456 , 1_000_000_007 ), 565291922 ); } #[test] fn test_is_prime () { assert! ( ! is_prime ( 0 )); assert! ( ! is_prime ( 1 )); assert! ( is_prime ( 2 )); assert! ( is_prime ( 3 )); assert! ( ! is_prime ( 4 )); assert! ( is_prime ( 5 )); assert! ( ! is_prime ( 6 )); assert! ( is_prime ( 7 )); assert! ( ! is_prime ( 8 )); assert! ( ! is_prime ( 9 )); // assert!(is_prime(57)); assert! ( ! is_prime ( 57 )); assert! ( ! is_prime ( 58 )); assert! ( is_prime ( 59 )); assert! ( ! is_prime ( 60 )); assert! ( is_prime ( 61 )); assert! ( ! is_prime ( 62 )); assert! ( ! is_prime ( 701928443 )); assert! ( is_prime ( 998244353 )); assert! ( ! is_prime ( 1_000_000_000 )); assert! ( is_prime ( 1_000_000_007 )); assert! ( is_prime ( i32 :: max_value ())); } #[test] fn test_is_prime_sieve () { let n = 1_000_000 ; let mut prime = vec! [ true ; n ]; prime [ 0 ] = false ; prime [ 1 ] = false ; for i in 0 .. n { assert_eq! ( prime [ i ], is_prime ( i as i32 )); if prime [ i ] { for j in ( 2 * i .. n ). step_by ( i ) { prime [ j ] = false ; } } } } #[test] fn test_inv_gcd () { for & ( a , b , g ) in & [ ( 0 , 1 , 1 ), ( 0 , 4 , 4 ), ( 0 , 7 , 7 ), ( 2 , 3 , 1 ), ( - 2 , 3 , 1 ), ( 4 , 6 , 2 ), ( - 4 , 6 , 2 ), ( 13 , 23 , 1 ), ( 57 , 81 , 3 ), ( 12345 , 67890 , 15 ), ( - 3141592 * 6535 , 3141592 * 8979 , 3141592 ), ( i64 :: max_value (), i64 :: max_value (), i64 :: max_value ()), ( i64 :: min_value (), i64 :: max_value (), 1 ), ] { let ( g_ , x ) = inv_gcd ( a , b ); assert_eq! ( g , g_ ); let b_ = b as i128 ; assert_eq! ((( x as i128 * a as i128 ) % b_ + b_ ) % b_ , g as i128 % b_ ); } } #[test] fn test_primitive_root () { for & p in & [ 2 , 3 , 5 , 7 , 233 , 200003 , 998244353 , 1_000_000_007 , i32 :: max_value (), ] { assert! ( is_prime ( p )); let g = primitive_root ( p ); if p != 2 { assert_ne! ( g , 1 ); } let q = p - 1 ; for i in ( 2 .. i32 :: max_value ()). take_while ( | i | i * i <= q ) { if q % i != 0 { break ; } for & r in & [ i , q / i ] { assert_ne! ( pow_mod ( g as i64 , r as i64 , p ), 1 ); } } assert_eq! ( pow_mod ( g as i64 , q as i64 , p ), 1 ); if p < 1_000_000 { assert_eq! ( ( 0 .. p - 1 ) . scan ( 1 , | i , _ | { * i = * i * g % p ; Some ( * i ) }) . collect :: < HashSet < _ >> () . len () as i32 , p - 1 ); } } } } } pub mod modint { //! Structs that treat the modular arithmetic. //! //! For most of the problems, It is sufficient to use [`ModInt1000000007`] or [`ModInt998244353`], which can be used as follows. //! //! ``` //! use ac_library_rs::ModInt1000000007 as Mint; // rename to whatever you want //! use proconio::{input, source::once::OnceSource}; //! //! input! { //! from OnceSource::from(\"1000000006 2\\n\"), //! a: Mint, //! b: Mint, //! } //! //! println!(\"{}\", a + b); // `1` //! ``` //! //! If the modulus is not fixed, you can use [`ModInt`] as follows. //! //! ``` //! use ac_library_rs::ModInt as Mint; // rename to whatever you want //! use proconio::{input, source::once::OnceSource}; //! //! input! { //! from OnceSource::from(\"3 3 7\\n\"), //! a: u32, //! b: u32, //! m: u32, //! } //! //! Mint::set_modulus(m); //! let a = Mint::new(a); //! let b = Mint::new(b); //! //! println!(\"{}\", a * b); // `2` //! ``` //! //! # Major changes from the original ACL //! //! - Converted the struct names to PascalCase. //! - Renamed `mod` \u2192 `modulus`. //! - Moduli are `u32`, not `i32`. //! - Each `Id` does not have a identifier number. Instead, they explicitly own `&'static LocalKey<RefCell<Barrett>>`. //! - The type of the argument of `pow` is `u64`, not `i64`. //! - Modints implement `FromStr` and `Display`. Modints in the original ACL don't have `operator<<` or `operator>>`. //! //! [`ModInt1000000007`]: ./type.ModInt1000000007.html //! [`ModInt998244353`]: ./type.ModInt998244353.html //! [`ModInt`]: ./type.ModInt.html use crate :: internal_math ; use std :: { cell :: RefCell , convert :: { Infallible , TryInto as _ }, fmt , hash :: { Hash , Hasher }, iter :: { Product , Sum }, marker :: PhantomData , ops :: { Add , AddAssign , Div , DivAssign , Mul , MulAssign , Neg , Sub , SubAssign }, str :: FromStr , sync :: atomic :: { self , AtomicU32 , AtomicU64 }, thread :: LocalKey , }; pub type ModInt1000000007 = StaticModInt < Mod1000000007 > ; pub type ModInt998244353 = StaticModInt < Mod998244353 > ; pub type ModInt = DynamicModInt < DefaultId > ; /// Represents _\u2124/m\u2124_ where _m_ is a constant value. /// /// Corresponds to `atcoder::static_modint` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt1000000007 as Mint; /// use proconio::{input, source::once::OnceSource}; /// /// input! { /// from OnceSource::from(\"1000000006 2\\n\"), /// a: Mint, /// b: Mint, /// } /// /// println!(\"{}\", a + b); // `1` /// ``` #[derive(Copy, Clone, Eq, PartialEq)] #[repr(transparent)] pub struct StaticModInt < M > { val : u32 , phantom : PhantomData < fn () -> M > , } impl < M : Modulus > StaticModInt < M > { /// Returns the modulus, which is [`<M as Modulus>::VALUE`]. /// /// Corresponds to `atcoder::static_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt1000000007 as Mint; /// /// assert_eq!(1_000_000_007, Mint::modulus()); /// ``` /// /// [`<M as Modulus>::VALUE`]: ../trait.Modulus.html#associatedconstant.VALUE #[inline(always)] pub fn modulus () -> u32 { M :: VALUE } /// Creates a new `StaticModInt`. /// /// Takes [any primitive integer]. /// /// Corresponds to the constructor of `atcoder::static_modint` in the original ACL. /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] pub fn new < T : RemEuclidU32 > ( val : T ) -> Self { Self :: raw ( val . rem_euclid_u32 ( M :: VALUE )) } /// Constructs a `StaticModInt` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::static_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// See [`ModIntBase::raw`] for more more details. /// /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw #[inline] pub fn raw ( val : u32 ) -> Self { Self { val , phantom : PhantomData , } } /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` in the original ACL. #[inline] pub fn val ( self ) -> u32 { self . val } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::static_modint::pow` in the original ACL. #[inline] pub fn pow ( self , n : u64 ) -> Self { < Self as ModIntBase > :: pow ( self , n ) } /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::static_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. #[inline] pub fn inv ( self ) -> Self { if M :: HINT_VALUE_IS_PRIME { if self . val () == 0 { panic! ( \"attempt to divide by zero\" ); } debug_assert! ( internal_math :: is_prime ( M :: VALUE . try_into (). unwrap ()), \"{} is not a prime number\" , M :: VALUE , ); self . pow (( M :: VALUE - 2 ). into ()) } else { Self :: inv_for_non_prime_modulus ( self ) } } } /// These methods are implemented for the struct. /// You don't need to `use` `ModIntBase` to call methods of `StaticModInt`. impl < M : Modulus > ModIntBase for StaticModInt < M > { #[inline(always)] fn modulus () -> u32 { Self :: modulus () } #[inline] fn raw ( val : u32 ) -> Self { Self :: raw ( val ) } #[inline] fn val ( self ) -> u32 { self . val () } #[inline] fn inv ( self ) -> Self { self . inv () } } /// Represents a modulus. /// /// # Example /// /// ``` /// macro_rules! modulus { /// ($($name:ident($value:expr, $is_prime:expr)),*) => { /// $( /// #[derive(Copy, Clone, Eq, PartialEq)] /// enum $name {} /// /// impl ac_library_rs::modint::Modulus for $name { /// const VALUE: u32 = $value; /// const HINT_VALUE_IS_PRIME: bool = $is_prime; /// /// fn butterfly_cache() -> &'static ::std::thread::LocalKey<::std::cell::RefCell<::std::option::Option<ac_library_rs::modint::ButterflyCache<Self>>>> { /// thread_local! { /// static BUTTERFLY_CACHE: ::std::cell::RefCell<::std::option::Option<ac_library_rs::modint::ButterflyCache<$name>>> = ::std::default::Default::default(); /// } /// &BUTTERFLY_CACHE /// } /// } /// )* /// }; /// } /// /// use ac_library_rs::StaticModInt; /// /// modulus!(Mod101(101, true), Mod103(103, true)); /// /// type Z101 = StaticModInt<Mod101>; /// type Z103 = StaticModInt<Mod103>; /// /// assert_eq!(Z101::new(101), Z101::new(0)); /// assert_eq!(Z103::new(103), Z103::new(0)); /// ``` pub trait Modulus : ' static + Copy + Eq { const VALUE : u32 ; const HINT_VALUE_IS_PRIME : bool ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> ; } /// Represents _1000000007_. #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum Mod1000000007 {} impl Modulus for Mod1000000007 { const VALUE : u32 = 1_000_000_007 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod1000000007 >>> = RefCell :: default (); } & BUTTERFLY_CACHE } } /// Represents _998244353_. #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum Mod998244353 {} impl Modulus for Mod998244353 { const VALUE : u32 = 998_244_353 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & ' static LocalKey < RefCell < Option < ButterflyCache < Self >>>> { thread_local! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod998244353 >>> = RefCell :: default (); } & BUTTERFLY_CACHE } } /// Cache for butterfly operations. pub struct ButterflyCache < M > { pub ( crate ) sum_e : Vec < StaticModInt < M >> , pub ( crate ) sum_ie : Vec < StaticModInt < M >> , } /// Represents _\u2124/m\u2124_ where _m_ is a dynamic value. /// /// Corresponds to `atcoder::dynamic_modint` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// use proconio::{input, source::once::OnceSource}; /// /// input! { /// from OnceSource::from(\"3 3 7\\n\"), /// a: u32, /// b: u32, /// m: u32, /// } /// /// Mint::set_modulus(m); /// let a = Mint::new(a); /// let b = Mint::new(b); /// /// println!(\"{}\", a * b); // `2` /// ``` #[derive(Copy, Clone, Eq, PartialEq)] #[repr(transparent)] pub struct DynamicModInt < I > { val : u32 , phantom : PhantomData < fn () -> I > , } impl < I : Id > DynamicModInt < I > { /// Returns the modulus. /// /// Corresponds to `atcoder::dynamic_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// /// assert_eq!(998_244_353, Mint::modulus()); // default modulus /// ``` #[inline] pub fn modulus () -> u32 { I :: companion_barrett (). umod () } /// Sets a modulus. /// /// Corresponds to `atcoder::dynamic_modint::set_mod` in the original ACL. /// /// # Constraints /// /// - This function must be called earlier than any other operation of `Self`. /// /// # Example /// /// ``` /// use ac_library_rs::ModInt as Mint; /// /// Mint::set_modulus(7); /// assert_eq!(7, Mint::modulus()); /// ``` #[inline] pub fn set_modulus ( modulus : u32 ) { if modulus == 0 { panic! ( \"the modulus must not be 0\" ); } I :: companion_barrett (). update ( modulus ); } /// Creates a new `DynamicModInt`. /// /// Takes [any primitive integer]. /// /// Corresponds to the constructor of `atcoder::dynamic_modint` in the original ACL. /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] pub fn new < T : RemEuclidU32 > ( val : T ) -> Self { < Self as ModIntBase > :: new ( val ) } /// Constructs a `DynamicModInt` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::dynamic_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// See [`ModIntBase::raw`] for more more details. /// /// [`ModIntBase::raw`]: ./trait.ModIntBase.html#tymethod.raw #[inline] pub fn raw ( val : u32 ) -> Self { Self { val , phantom : PhantomData , } } /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` in the original ACL. #[inline] pub fn val ( self ) -> u32 { self . val } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::dynamic_modint::pow` in the original ACL. #[inline] pub fn pow ( self , n : u64 ) -> Self { < Self as ModIntBase > :: pow ( self , n ) } /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::dynamic_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. #[inline] pub fn inv ( self ) -> Self { Self :: inv_for_non_prime_modulus ( self ) } } /// These methods are implemented for the struct. /// You don't need to `use` `ModIntBase` to call methods of `DynamicModInt`. impl < I : Id > ModIntBase for DynamicModInt < I > { #[inline] fn modulus () -> u32 { Self :: modulus () } #[inline] fn raw ( val : u32 ) -> Self { Self :: raw ( val ) } #[inline] fn val ( self ) -> u32 { self . val () } #[inline] fn inv ( self ) -> Self { self . inv () } } pub trait Id : ' static + Copy + Eq { fn companion_barrett () -> & ' static Barrett ; } #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)] pub enum DefaultId {} impl Id for DefaultId { fn companion_barrett () -> & ' static Barrett { static BARRETT : Barrett = Barrett :: default (); & BARRETT } } /// Pair of _m_ and _ceil(2\u2076\u2074/m)_. pub struct Barrett { m : AtomicU32 , im : AtomicU64 , } impl Barrett { /// Creates a new `Barrett`. #[inline] pub const fn new ( m : u32 ) -> Self { Self { m : AtomicU32 :: new ( m ), im : AtomicU64 :: new (( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 )), } } #[inline] const fn default () -> Self { Self :: new ( 998_244_353 ) } #[inline] fn update ( & self , m : u32 ) { let im = ( - 1 i64 as u64 / m as u64 ). wrapping_add ( 1 ); self . m . store ( m , atomic :: Ordering :: SeqCst ); self . im . store ( im , atomic :: Ordering :: SeqCst ); } #[inline] fn umod ( & self ) -> u32 { self . m . load ( atomic :: Ordering :: SeqCst ) } #[inline] fn mul ( & self , a : u32 , b : u32 ) -> u32 { let m = self . m . load ( atomic :: Ordering :: SeqCst ); let im = self . im . load ( atomic :: Ordering :: SeqCst ); internal_math :: mul_mod ( a , b , m , im ) } } impl Default for Barrett { #[inline] fn default () -> Self { Self :: default () } } /// A trait for [`StaticModInt`] and [`DynamicModInt`]. /// /// Corresponds to `atcoder::internal::modint_base` in the original ACL. /// /// [`StaticModInt`]: ../struct.StaticModInt.html /// [`DynamicModInt`]: ../struct.DynamicModInt.html pub trait ModIntBase : Default + FromStr + From < i8 > + From < i16 > + From < i32 > + From < i64 > + From < i128 > + From < isize > + From < u8 > + From < u16 > + From < u32 > + From < u64 > + From < u128 > + From < usize > + Copy + Eq + Hash + fmt :: Display + fmt :: Debug + Neg < Output = Self > + Add < Output = Self > + Sub < Output = Self > + Mul < Output = Self > + Div < Output = Self > + AddAssign + SubAssign + MulAssign + DivAssign { /// Returns the modulus. /// /// Corresponds to `atcoder::static_modint::mod` and `atcoder::dynamic_modint::mod` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _: u32 = Z::modulus(); /// } /// ``` fn modulus () -> u32 ; /// Constructs a `Self` from a `val < Self::modulus()` without checking it. /// /// Corresponds to `atcoder::static_modint::raw` and `atcoder::dynamic_modint::raw` in the original ACL. /// /// # Constraints /// /// - `val` is less than `Self::modulus()` /// /// **Note that all operations assume that inner values are smaller than the modulus.** /// If `val` is greater than or equal to `Self::modulus()`, the behaviors are not defined. /// /// ```should_panic /// use ac_library_rs::ModInt1000000007 as Mint; /// /// let x = Mint::raw(1_000_000_007); /// let y = x + x; /// assert_eq!(0, y.val()); /// ``` /// /// ```text /// thread 'main' panicked at 'assertion failed: `(left == right)` /// left: `0`, /// right: `1000000007`', src/modint.rs:8:1 /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace /// ``` /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() -> Z { /// debug_assert!(Z::modulus() >= 100); /// /// let mut acc = Z::new(0); /// for i in 0..100 { /// if i % 3 == 0 { /// // I know `i` is smaller than the modulus! /// acc += Z::raw(i); /// } /// } /// acc /// } /// ``` fn raw ( val : u32 ) -> Self ; /// Retruns the representative. /// /// Corresponds to `atcoder::static_modint::val` and `atcoder::dynamic_modint::val` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>(x: Z) { /// let _: u32 = x.val(); /// } /// ``` fn val ( self ) -> u32 ; /// Retruns the multiplicative inverse of `self`. /// /// Corresponds to `atcoder::static_modint::inv` and `atcoder::dynamic_modint::inv` in the original ACL. /// /// # Panics /// /// Panics if the multiplicative inverse does not exist. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>(x: Z) { /// let _: Z = x.inv(); /// } /// ``` fn inv ( self ) -> Self ; /// Creates a new `Self`. /// /// Takes [any primitive integer]. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _ = Z::new(1u32); /// let _ = Z::new(1usize); /// let _ = Z::new(-1i64); /// } /// ``` /// /// [any primitive integer]: ../trait.RemEuclidU32.html #[inline] fn new < T : RemEuclidU32 > ( val : T ) -> Self { Self :: raw ( val . rem_euclid_u32 ( Self :: modulus ())) } /// Returns `self` to the power of `n`. /// /// Corresponds to `atcoder::static_modint::pow` and `atcoder::dynamic_modint::pow` in the original ACL. /// /// # Example /// /// ``` /// use ac_library_rs::modint::ModIntBase; /// /// fn f<Z: ModIntBase>() { /// let _: Z = Z::new(2).pow(3); /// } /// ``` #[inline] fn pow ( self , mut n : u64 ) -> Self { let mut x = self ; let mut r = Self :: raw ( 1 ); while n > 0 { if n & 1 == 1 { r *= x ; } x *= x ; n >>= 1 ; } r } } /// A trait for `{StaticModInt, DynamicModInt, ModIntBase}::new`. pub trait RemEuclidU32 { /// Calculates `self` _mod_ `modulus` losslessly. fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 ; } macro_rules! impl_rem_euclid_u32_for_small_signed { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { ( self as i64 ). rem_euclid ( i64 :: from ( modulus )) as _ } } ) * } } impl_rem_euclid_u32_for_small_signed ! ( i8 , i16 , i32 , i64 , isize ); impl RemEuclidU32 for i128 { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { self . rem_euclid ( i128 :: from ( modulus )) as _ } } macro_rules! impl_rem_euclid_u32_for_small_unsigned { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { self as u32 % modulus } } ) * } } macro_rules! impl_rem_euclid_u32_for_large_unsigned { ( $($ty : tt ), * ) => { $( impl RemEuclidU32 for $ty { #[inline] fn rem_euclid_u32 ( self , modulus : u32 ) -> u32 { ( self % ( modulus as $ty )) as _ } } ) * } } impl_rem_euclid_u32_for_small_unsigned ! ( u8 , u16 , u32 ); impl_rem_euclid_u32_for_large_unsigned ! ( u64 , u128 ); #[cfg(target_pointer_width = \"32\" )] impl_rem_euclid_u32_for_small_unsigned ! ( usize ); #[cfg(target_pointer_width = \"64\" )] impl_rem_euclid_u32_for_large_unsigned ! ( usize ); trait InternalImplementations : ModIntBase { #[inline] fn inv_for_non_prime_modulus ( this : Self ) -> Self { let ( gcd , x ) = internal_math :: inv_gcd ( this . val (). into (), Self :: modulus (). into ()); if gcd != 1 { panic! ( \"the multiplicative inverse does not exist\" ); } Self :: new ( x ) } #[inline] fn default_impl () -> Self { Self :: raw ( 0 ) } #[inline] fn from_str_impl ( s : & str ) -> Result < Self , Infallible > { Ok ( s . parse :: < i64 > () . map ( Self :: new ) . unwrap_or_else ( | _ | todo! ( \"parsing as an arbitrary precision integer?\" ))) } #[inline] fn hash_impl ( this : & Self , state : & mut impl Hasher ) { this . val (). hash ( state ) } #[inline] fn display_impl ( this : & Self , f : & mut fmt :: Formatter ) -> fmt :: Result { fmt :: Display :: fmt ( & this . val (), f ) } #[inline] fn debug_impl ( this : & Self , f : & mut fmt :: Formatter ) -> fmt :: Result { fmt :: Debug :: fmt ( & this . val (), f ) } #[inline] fn neg_impl ( this : Self ) -> Self { Self :: sub_impl ( Self :: raw ( 0 ), this ) } #[inline] fn add_impl ( lhs : Self , rhs : Self ) -> Self { let modulus = Self :: modulus (); let mut val = lhs . val () + rhs . val (); if val >= modulus { val -= modulus ; } Self :: raw ( val ) } #[inline] fn sub_impl ( lhs : Self , rhs : Self ) -> Self { let modulus = Self :: modulus (); let mut val = lhs . val (). wrapping_sub ( rhs . val ()); if val >= modulus { val = val . wrapping_add ( modulus ) } Self :: raw ( val ) } fn mul_impl ( lhs : Self , rhs : Self ) -> Self ; #[inline] fn div_impl ( lhs : Self , rhs : Self ) -> Self { Self :: mul_impl ( lhs , rhs . inv ()) } } impl < M : Modulus > InternalImplementations for StaticModInt < M > { #[inline] fn mul_impl ( lhs : Self , rhs : Self ) -> Self { Self :: raw (( u64 :: from ( lhs . val ()) * u64 :: from ( rhs . val ()) % u64 :: from ( M :: VALUE )) as u32 ) } } impl < I : Id > InternalImplementations for DynamicModInt < I > { #[inline] fn mul_impl ( lhs : Self , rhs : Self ) -> Self { Self :: raw ( I :: companion_barrett (). mul ( lhs . val , rhs . val )) } } macro_rules! impl_basic_traits { () => {}; ( impl < $generic_param : ident : $generic_param_bound : tt > _ for $self : ty ; $($rest : tt ) * ) => { impl < $generic_param : $generic_param_bound > Default for $self { #[inline] fn default () -> Self { Self :: default_impl () } } impl < $generic_param : $generic_param_bound > FromStr for $self { type Err = Infallible ; #[inline] fn from_str ( s : & str ) -> Result < Self , Infallible > { Self :: from_str_impl ( s ) } } impl < $generic_param : $generic_param_bound , V : RemEuclidU32 > From < V > for $self { #[inline] fn from ( from : V ) -> Self { Self :: new ( from ) } } #[allow(clippy::derive_hash_xor_eq)] impl < $generic_param : $generic_param_bound > Hash for $self { #[inline] fn hash < H : Hasher > ( & self , state : & mut H ) { Self :: hash_impl ( self , state ) } } impl < $generic_param : $generic_param_bound > fmt :: Display for $self { #[inline] fn fmt ( & self , f : & mut fmt :: Formatter <' _ > ) -> fmt :: Result { Self :: display_impl ( self , f ) } } impl < $generic_param : $generic_param_bound > fmt :: Debug for $self { #[inline] fn fmt ( & self , f : & mut fmt :: Formatter <' _ > ) -> fmt :: Result { Self :: debug_impl ( self , f ) } } impl < $generic_param : $generic_param_bound > Neg for $self { type Output = $self ; #[inline] fn neg ( self ) -> $self { Self :: neg_impl ( self ) } } impl < $generic_param : $generic_param_bound > Neg for &' _ $self { type Output = $self ; #[inline] fn neg ( self ) -> $self { < $self > :: neg_impl ( * self ) } } impl_basic_traits ! ( $($rest ) * ); }; } impl_basic_traits ! { impl < M : Modulus > _ for StaticModInt < M > ; impl < I : Id > _ for DynamicModInt < I > ; } macro_rules! impl_bin_ops { () => {}; ( for < $($generic_param : ident : $generic_param_bound : tt ), *> < $lhs_ty : ty > ~ < $rhs_ty : ty > -> $output : ty { { $lhs_body : expr } ~ { $rhs_body : expr } } $($rest : tt ) * ) => { impl < $($generic_param : $generic_param_bound ), *> Add < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn add ( self , rhs : $rhs_ty ) -> $output { < $output > :: add_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Sub < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn sub ( self , rhs : $rhs_ty ) -> $output { < $output > :: sub_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Mul < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn mul ( self , rhs : $rhs_ty ) -> $output { < $output > :: mul_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl < $($generic_param : $generic_param_bound ), *> Div < $rhs_ty > for $lhs_ty { type Output = $output ; #[inline] fn div ( self , rhs : $rhs_ty ) -> $output { < $output > :: div_impl ( apply ( $lhs_body , self ), apply ( $rhs_body , rhs )) } } impl_bin_ops ! ( $($rest ) * ); }; } macro_rules! impl_assign_ops { () => {}; ( for < $($generic_param : ident : $generic_param_bound : tt ), *> < $lhs_ty : ty > ~= < $rhs_ty : ty > { _ ~= { $rhs_body : expr } } $($rest : tt ) * ) => { impl < $($generic_param : $generic_param_bound ), *> AddAssign < $rhs_ty > for $lhs_ty { #[inline] fn add_assign ( & mut self , rhs : $rhs_ty ) { * self = * self + apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> SubAssign < $rhs_ty > for $lhs_ty { #[inline] fn sub_assign ( & mut self , rhs : $rhs_ty ) { * self = * self - apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> MulAssign < $rhs_ty > for $lhs_ty { #[inline] fn mul_assign ( & mut self , rhs : $rhs_ty ) { * self = * self * apply ( $rhs_body , rhs ); } } impl < $($generic_param : $generic_param_bound ), *> DivAssign < $rhs_ty > for $lhs_ty { #[inline] fn div_assign ( & mut self , rhs : $rhs_ty ) { * self = * self / apply ( $rhs_body , rhs ); } } impl_assign_ops ! ( $($rest ) * ); }; } #[inline] fn apply < F : FnOnce ( X ) -> O , X , O > ( f : F , x : X ) -> O { f ( x ) } impl_bin_ops ! { for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { | x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&' _ StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { |& x | x } } for < M : Modulus > <&' _ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { | x | x } } for < M : Modulus > <&' _ StaticModInt < M > > ~ <&' _ StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { |& x | x } } for < I : Id > < DynamicModInt < I > > ~ < DynamicModInt < I > > -> DynamicModInt < I > { { | x | x } ~ { | x | x } } for < I : Id > < DynamicModInt < I > > ~ <&' _ DynamicModInt < I >> -> DynamicModInt < I > { { | x | x } ~ { |& x | x } } for < I : Id > <&' _ DynamicModInt < I >> ~ < DynamicModInt < I > > -> DynamicModInt < I > { { |& x | x } ~ { | x | x } } for < I : Id > <&' _ DynamicModInt < I >> ~ <&' _ DynamicModInt < I >> -> DynamicModInt < I > { { |& x | x } ~ { |& x | x } } for < M : Modulus , T : RemEuclidU32 > < StaticModInt < M > > ~ < T > -> StaticModInt < M > { { | x | x } ~ { StaticModInt :: < M > :: new } } for < I : Id , T : RemEuclidU32 > < DynamicModInt < I > > ~ < T > -> DynamicModInt < I > { { | x | x } ~ { DynamicModInt :: < I > :: new } } } impl_assign_ops ! { for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > { _ ~= { | x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&' _ StaticModInt < M > > { _ ~= { |& x | x } } for < I : Id > < DynamicModInt < I >> ~= < DynamicModInt < I > > { _ ~= { | x | x } } for < I : Id > < DynamicModInt < I >> ~= <&' _ DynamicModInt < I >> { _ ~= { |& x | x } } for < M : Modulus , T : RemEuclidU32 > < StaticModInt < M > > ~= < T > { _ ~= { StaticModInt :: < M > :: new } } for < I : Id , T : RemEuclidU32 > < DynamicModInt < I >> ~= < T > { _ ~= { DynamicModInt :: < I > :: new } } } macro_rules! impl_folding { () => {}; ( impl < $generic_param : ident : $generic_param_bound : tt > $trait : ident < _ > for $self : ty { fn $method : ident ( _ ) -> _ { _ ( $unit : expr , $op : expr ) } } $($rest : tt ) * ) => { impl < $generic_param : $generic_param_bound > $trait < Self > for $self { #[inline] fn $method < S > ( iter : S ) -> Self where S : Iterator < Item = Self > , { iter . fold ( $unit , $op ) } } impl <' a , $generic_param : $generic_param_bound > $trait <&' a Self > for $self { #[inline] fn $method < S > ( iter : S ) -> Self where S : Iterator < Item = &' a Self > , { iter . fold ( $unit , $op ) } } impl_folding ! ( $($rest ) * ); }; } impl_folding ! { impl < M : Modulus > Sum < _ > for StaticModInt < M > { fn sum ( _ ) -> _ { _ ( Self :: raw ( 0 ), Add :: add ) } } impl < M : Modulus > Product < _ > for StaticModInt < M > { fn product ( _ ) -> _ { _ ( Self :: raw ( 1 ), Mul :: mul ) } } impl < I : Id > Sum < _ > for DynamicModInt < I > { fn sum ( _ ) -> _ { _ ( Self :: raw ( 0 ), Add :: add ) } } impl < I : Id > Product < _ > for DynamicModInt < I > { fn product ( _ ) -> _ { _ ( Self :: raw ( 1 ), Mul :: mul ) } } } #[cfg(test)] mod tests { use crate :: modint :: ModInt1000000007 ; #[test] fn static_modint_new () { assert_eq! ( 0 , ModInt1000000007 :: new ( 0 u32 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 u32 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 u32 ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 u64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 u64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 u64 ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 usize ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 usize ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 usize ). val ); assert_eq! ( 0 , ModInt1000000007 :: new ( 0 i64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1 i64 ). val ); assert_eq! ( 1 , ModInt1000000007 :: new ( 1_000_000_008 i64 ). val ); assert_eq! ( 1_000_000_006 , ModInt1000000007 :: new ( - 1 i64 ). val ); } #[test] fn static_modint_add () { fn add ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) + ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 2 , add ( 1 , 1 )); assert_eq! ( 1 , add ( 1_000_000_006 , 2 )); } #[test] fn static_modint_sub () { fn sub ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) - ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 1 , sub ( 2 , 1 )); assert_eq! ( 1_000_000_006 , sub ( 0 , 1 )); } #[test] fn static_modint_mul () { fn mul ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) * ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 1 , mul ( 1 , 1 )); assert_eq! ( 4 , mul ( 2 , 2 )); assert_eq! ( 999_999_937 , mul ( 100_000 , 100_000 )); } #[test] fn static_modint_prime_div () { fn div ( lhs : u32 , rhs : u32 ) -> u32 { ( ModInt1000000007 :: new ( lhs ) / ModInt1000000007 :: new ( rhs )). val } assert_eq! ( 0 , div ( 0 , 1 )); assert_eq! ( 1 , div ( 1 , 1 )); assert_eq! ( 1 , div ( 2 , 2 )); assert_eq! ( 23_809_524 , div ( 1 , 42 )); } #[test] fn static_modint_sum () { fn sum ( values : & [ i64 ]) -> ModInt1000000007 { values . iter (). copied (). map ( ModInt1000000007 :: new ). sum () } assert_eq! ( ModInt1000000007 :: new ( - 3 ), sum ( & [ - 1 , 2 , - 3 , 4 , - 5 ])); } #[test] fn static_modint_product () { fn product ( values : & [ i64 ]) -> ModInt1000000007 { values . iter (). copied (). map ( ModInt1000000007 :: new ). product () } assert_eq! ( ModInt1000000007 :: new ( - 120 ), product ( & [ - 1 , 2 , - 3 , 4 , - 5 ])); } #[test] fn static_modint_binop_coercion () { let f = ModInt1000000007 :: new ; let a = 10_293_812_ usize ; let b = 9_083_240_982_ usize ; assert_eq! ( f ( a ) + f ( b ), f ( a ) + b ); assert_eq! ( f ( a ) - f ( b ), f ( a ) - b ); assert_eq! ( f ( a ) * f ( b ), f ( a ) * b ); assert_eq! ( f ( a ) / f ( b ), f ( a ) / b ); } #[test] fn static_modint_assign_coercion () { let f = ModInt1000000007 :: new ; let a = f ( 10_293_812_ usize ); let b = 9_083_240_982_ usize ; let expected = ((( a + b ) * b ) - b ) / b ; let mut c = a ; c += b ; c *= b ; c -= b ; c /= b ; assert_eq! ( expected , c ); } } } use convolution :: * ; use modint :: * ;","title":"Convolution (ACL-RS)"},{"location":"rust/convolution/#_1","text":"","title":"\u4f7f\u3044\u65b9"},{"location":"rust/convolution/#modint","text":"let cl = convolution_raw :: < i64 , Mod998244353 > ( & al , & bl ); \u305d\u308c\u305e\u308c\u306e\u578b\u306f Vec<i64>","title":"ModInt \u4e0d\u4f7f\u7528"},{"location":"rust/convolution/#modint_1","text":"let cml = convolution :: < Mod998244353 > ( & aml , & bml ); \u305d\u308c\u305e\u308c\u306e\u578b\u306f Vec<StaticModInt<Mod998244353>>","title":"ModInt \u4f7f\u7528"},{"location":"rust/convolution/#_2","text":"ACL-F : \u7573\u307f\u8fbc\u307f\u306e\u7d50\u679c\u3092 Mod \u3067\u6c42\u3081\u308b\u3060\u3051 fn solve1 () { input ! { n : usize , m : usize , al : [ i64 ; n ], bl : [ i64 ; m ], } // ModInt \u4e0d\u4f7f\u7528 let cl = convolution_raw :: < i64 , Mod998244353 > ( & al , & bl ); for c in cl { print! ( \"{} \" , c ); } println! (); } fn solve2 () { input ! { n : usize , m : usize , al : [ i64 ; n ], bl : [ i64 ; m ], } // ModInt \u4f7f\u7528 let aml = al . iter (). map ( |& x | ModInt998244353 :: new ( x )). collect_vec (); let bml = bl . iter (). map ( |& x | ModInt998244353 :: new ( x )). collect_vec (); let cml = convolution :: < Mod998244353 > ( & aml , & bml ); for c in cml { print! ( \"{} \" , c ); } println! (); }","title":"\u4f8b\u984c"},{"location":"rust/lazy_segtree/","text":"LazySegTree Source Code pub struct LazySegTree < S , Op , F , Mapping , Composition > where S : Copy + std :: fmt :: Debug , Op : Fn ( S , S ) -> S , F : Copy + std :: cmp :: PartialEq + std :: fmt :: Debug , Mapping : Fn ( F , S ) -> S , Composition : Fn ( F , F ) -> F , { n : usize , // the size of the original elements e : S , // identity element op : Op , // size : usize , // leaf (vec) size. the whole tree size is 2*size. data : Vec < S > , // 1-indexed (ignore 0) lazy : Vec < F > , // 1-indexed (ignore 0) mapping : Mapping , // f(x) composition : Composition , // f(g()) id : F , // id(x) -> x } impl < S , Op , F , Mapping , Composition > LazySegTree < S , Op , F , Mapping , Composition > where S : Copy + std :: fmt :: Debug , Op : Fn ( S , S ) -> S , F : Copy + std :: cmp :: PartialEq + std :: fmt :: Debug , Mapping : Fn ( F , S ) -> S , Composition : Fn ( F , F ) -> F , { pub fn new ( n : usize , e : S , op : Op , id : F , mapping : Mapping , composition : Composition ) -> Self { Self :: new_from_vec ( & vec! [ e ; n ], e , op , id , mapping , composition ) } pub fn new_from_vec ( vals : & Vec < S > , e : S , op : Op , id : F , mapping : Mapping , composition : Composition , ) -> Self { let n = vals . len (); let mut size = 1 ; while size < n { size *= 2 ; } let mut data = vec! [ e ; size * 2 ]; for i in 0 .. n { data [ size + i ] = vals [ i ]; } for i in ( 1 .. size ). rev () { data [ i ] = op ( data [ i * 2 ], data [ i * 2 + 1 ]); } LazySegTree { n , e , op , size , data , lazy : vec ! [ id ; size * 2 ], mapping , composition , id , } } pub fn eval ( & mut self , k : usize ) { if self . lazy [ k ] == self . id { return ; } if k < self . size { self . lazy [ k * 2 ] = ( self . composition )( self . lazy [ k ], self . lazy [ k * 2 ]); self . lazy [ k * 2 + 1 ] = ( self . composition )( self . lazy [ k ], self . lazy [ k * 2 + 1 ]); } self . data [ k ] = ( self . mapping )( self . lazy [ k ], self . data [ k ]); self . lazy [ k ] = self . id ; } fn prod_rec ( & mut self , tl : usize , tr : usize , ck : usize , cl : usize , cr : usize ) -> S { // t: target, c: current self . eval ( ck ); if tr <= cl || cr <= tl { return self . e ; } if tl <= cl && cr <= tr { return self . data [ ck ]; } else { let half = ( cl + cr ) / 2 ; let lv = self . prod_rec ( tl , tr , ck * 2 , cl , half ); let rv = self . prod_rec ( tl , tr , ck * 2 + 1 , half , cr ); return ( self . op )( lv , rv ); } } pub fn prod ( & mut self , l : usize , r : usize ) -> S { self . prod_rec ( l , r , 1 , 0 , self . size ) // 1-indexed } fn apply_rec ( & mut self , tl : usize , tr : usize , f : F , ck : usize , cl : usize , cr : usize ) { self . eval ( ck ); if tr <= cl || cr <= tl { return ; } if tl <= cl && cr <= tr { self . lazy [ ck ] = ( self . composition )( f , self . lazy [ ck ]); self . eval ( ck ); } else { let half = ( cl + cr ) / 2 ; self . apply_rec ( tl , tr , f , ck * 2 , cl , half ); self . apply_rec ( tl , tr , f , ck * 2 + 1 , half , cr ); self . data [ ck ] = ( self . op )( self . data [ ck * 2 ], self . data [ ck * 2 + 1 ]); } } pub fn apply ( & mut self , l : usize , r : usize , f : F ) { self . apply_rec ( l , r , f , 1 , 0 , self . size ); } pub fn print_vals ( & mut self ) { // update leaf vals for i in 0 .. self . n { self . prod ( i , i + 1 ); } println! ( \"{:?}\" , self . data [ self . size .. self . size + self . n ] . iter () . collect :: < Vec < _ >> () ); } } \u4f7f\u3044\u65b9 \u521d\u671f\u5316 let mut seg = LazySegTree :: new_from_vec ( & vals , e , op , id , mapping , composition ); vals : \u521d\u671f\u306e Vec e : \u4e8c\u9805\u6f14\u7b97\u306e\u5358\u4f4d\u5143\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 0 \u3001\u533a\u9593 min \u306a\u3089 INF \uff09 op : \u4e8c\u9805\u6f14\u7b97\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 |a,b| a+b \uff09 id : \u30de\u30c3\u30d4\u30f3\u30b0\u306e\u6052\u7b49\u5199\u50cf\uff08\u533a\u9593\u52a0\u7b97\u66f4\u65b0\u306a\u3089 0 \u3001\u533a\u9593\u5909\u66f4\u306a\u3089\u3042\u308a\u5f97\u306a\u3044\u5024 INF \uff09 mapping : \u533a\u9593\u64cd\u4f5c\u6f14\u7b97 composition : \u5199\u50cf\u306e\u5408\u6210\uff08 |f,g| f(g(x)) \uff09 \u66f4\u65b0 seg . apply ( left , right , f ) # [ left , right ) \u5024\u53d6\u5f97 seg . prod ( left , right ) # [ left , right ) \u4f8b\u984c ARC045-B : \u533a\u9593\u52a0\u7b97\u66f4\u65b0 & \u533a\u9593\u6700\u5c0f\u5024\u53d6\u5f97 fn solve () { input ! { n : usize , m : usize , stl : [( Usize1 , Usize1 ); m ], } let op = | a : i64 , b | a . min ( b ); let e = 1e9 as i64 ; let id : i64 = 0 ; let mapping = | f , x | f + x ; let composition = | f , g | f + g ; let mut seg = LazySegTree :: new_from_vec ( & vec! [ 0 ; n ], e , op , id , mapping , composition ); for & ( s , t ) in & stl { seg . apply ( s , t + 1 , 1 ); } let mut ans = vec! []; for i in 0 .. m { let ( s , t ) = stl [ i ]; seg . apply ( s , t + 1 , - 1 ); if seg . prod ( 0 , n ) > 0 { ans . push ( i + 1 ); } seg . apply ( s , t + 1 , 1 ); } println! ( \"{}\" , ans . len ()); for & a in & ans { println! ( \"{}\" , a ); } } \u4f8b\u984c \u533a\u9593\u52a0\u7b97\u66f4\u65b0 & \u533a\u9593\u52a0\u7b97\u53d6\u5f97 fn solve2 () { type P = ( i64 , i64 ); let vals = [ 1 , 2 , 3 , 4 , 5 ]; let vals = vals . iter (). map ( |& v | ( v , 1 )). collect_vec (); let op = | a : P , b : P | ( a . 0 + b . 0 , a . 1 + b . 1 ); let e = ( 0 , 0 ); let id = std :: i64 :: MAX ; let mapping = | f : i64 , x : P | { if f == id { x } else { ( f * x . 1 , x . 1 ) } }; let composition = | f : i64 , g : i64 | { if f == id { g } else { f } }; let mut seg = LazySegTree :: new_from_vec ( & vals , e , op , id , mapping , composition ); assert! ( seg . prod ( 0 , 5 ). 0 == 15 ); seg . apply ( 1 , 3 , 10 ); assert! ( seg . prod ( 0 , 3 ). 0 == 21 ); seg . apply ( 2 , 4 , - 5 ); assert! ( seg . prod ( 0 , 5 ). 0 == 6 ); seg . apply ( 0 , 1 , - 100 ); assert! ( seg . prod ( 0 , 5 ). 0 == - 95 ); }","title":"LazySegTree"},{"location":"rust/lazy_segtree/#lazysegtree","text":"Source Code pub struct LazySegTree < S , Op , F , Mapping , Composition > where S : Copy + std :: fmt :: Debug , Op : Fn ( S , S ) -> S , F : Copy + std :: cmp :: PartialEq + std :: fmt :: Debug , Mapping : Fn ( F , S ) -> S , Composition : Fn ( F , F ) -> F , { n : usize , // the size of the original elements e : S , // identity element op : Op , // size : usize , // leaf (vec) size. the whole tree size is 2*size. data : Vec < S > , // 1-indexed (ignore 0) lazy : Vec < F > , // 1-indexed (ignore 0) mapping : Mapping , // f(x) composition : Composition , // f(g()) id : F , // id(x) -> x } impl < S , Op , F , Mapping , Composition > LazySegTree < S , Op , F , Mapping , Composition > where S : Copy + std :: fmt :: Debug , Op : Fn ( S , S ) -> S , F : Copy + std :: cmp :: PartialEq + std :: fmt :: Debug , Mapping : Fn ( F , S ) -> S , Composition : Fn ( F , F ) -> F , { pub fn new ( n : usize , e : S , op : Op , id : F , mapping : Mapping , composition : Composition ) -> Self { Self :: new_from_vec ( & vec! [ e ; n ], e , op , id , mapping , composition ) } pub fn new_from_vec ( vals : & Vec < S > , e : S , op : Op , id : F , mapping : Mapping , composition : Composition , ) -> Self { let n = vals . len (); let mut size = 1 ; while size < n { size *= 2 ; } let mut data = vec! [ e ; size * 2 ]; for i in 0 .. n { data [ size + i ] = vals [ i ]; } for i in ( 1 .. size ). rev () { data [ i ] = op ( data [ i * 2 ], data [ i * 2 + 1 ]); } LazySegTree { n , e , op , size , data , lazy : vec ! [ id ; size * 2 ], mapping , composition , id , } } pub fn eval ( & mut self , k : usize ) { if self . lazy [ k ] == self . id { return ; } if k < self . size { self . lazy [ k * 2 ] = ( self . composition )( self . lazy [ k ], self . lazy [ k * 2 ]); self . lazy [ k * 2 + 1 ] = ( self . composition )( self . lazy [ k ], self . lazy [ k * 2 + 1 ]); } self . data [ k ] = ( self . mapping )( self . lazy [ k ], self . data [ k ]); self . lazy [ k ] = self . id ; } fn prod_rec ( & mut self , tl : usize , tr : usize , ck : usize , cl : usize , cr : usize ) -> S { // t: target, c: current self . eval ( ck ); if tr <= cl || cr <= tl { return self . e ; } if tl <= cl && cr <= tr { return self . data [ ck ]; } else { let half = ( cl + cr ) / 2 ; let lv = self . prod_rec ( tl , tr , ck * 2 , cl , half ); let rv = self . prod_rec ( tl , tr , ck * 2 + 1 , half , cr ); return ( self . op )( lv , rv ); } } pub fn prod ( & mut self , l : usize , r : usize ) -> S { self . prod_rec ( l , r , 1 , 0 , self . size ) // 1-indexed } fn apply_rec ( & mut self , tl : usize , tr : usize , f : F , ck : usize , cl : usize , cr : usize ) { self . eval ( ck ); if tr <= cl || cr <= tl { return ; } if tl <= cl && cr <= tr { self . lazy [ ck ] = ( self . composition )( f , self . lazy [ ck ]); self . eval ( ck ); } else { let half = ( cl + cr ) / 2 ; self . apply_rec ( tl , tr , f , ck * 2 , cl , half ); self . apply_rec ( tl , tr , f , ck * 2 + 1 , half , cr ); self . data [ ck ] = ( self . op )( self . data [ ck * 2 ], self . data [ ck * 2 + 1 ]); } } pub fn apply ( & mut self , l : usize , r : usize , f : F ) { self . apply_rec ( l , r , f , 1 , 0 , self . size ); } pub fn print_vals ( & mut self ) { // update leaf vals for i in 0 .. self . n { self . prod ( i , i + 1 ); } println! ( \"{:?}\" , self . data [ self . size .. self . size + self . n ] . iter () . collect :: < Vec < _ >> () ); } }","title":"LazySegTree"},{"location":"rust/lazy_segtree/#_1","text":"","title":"\u4f7f\u3044\u65b9"},{"location":"rust/lazy_segtree/#_2","text":"let mut seg = LazySegTree :: new_from_vec ( & vals , e , op , id , mapping , composition ); vals : \u521d\u671f\u306e Vec e : \u4e8c\u9805\u6f14\u7b97\u306e\u5358\u4f4d\u5143\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 0 \u3001\u533a\u9593 min \u306a\u3089 INF \uff09 op : \u4e8c\u9805\u6f14\u7b97\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 |a,b| a+b \uff09 id : \u30de\u30c3\u30d4\u30f3\u30b0\u306e\u6052\u7b49\u5199\u50cf\uff08\u533a\u9593\u52a0\u7b97\u66f4\u65b0\u306a\u3089 0 \u3001\u533a\u9593\u5909\u66f4\u306a\u3089\u3042\u308a\u5f97\u306a\u3044\u5024 INF \uff09 mapping : \u533a\u9593\u64cd\u4f5c\u6f14\u7b97 composition : \u5199\u50cf\u306e\u5408\u6210\uff08 |f,g| f(g(x)) \uff09","title":"\u521d\u671f\u5316"},{"location":"rust/lazy_segtree/#_3","text":"seg . apply ( left , right , f ) # [ left , right )","title":"\u66f4\u65b0"},{"location":"rust/lazy_segtree/#_4","text":"seg . prod ( left , right ) # [ left , right )","title":"\u5024\u53d6\u5f97"},{"location":"rust/lazy_segtree/#_5","text":"ARC045-B : \u533a\u9593\u52a0\u7b97\u66f4\u65b0 & \u533a\u9593\u6700\u5c0f\u5024\u53d6\u5f97 fn solve () { input ! { n : usize , m : usize , stl : [( Usize1 , Usize1 ); m ], } let op = | a : i64 , b | a . min ( b ); let e = 1e9 as i64 ; let id : i64 = 0 ; let mapping = | f , x | f + x ; let composition = | f , g | f + g ; let mut seg = LazySegTree :: new_from_vec ( & vec! [ 0 ; n ], e , op , id , mapping , composition ); for & ( s , t ) in & stl { seg . apply ( s , t + 1 , 1 ); } let mut ans = vec! []; for i in 0 .. m { let ( s , t ) = stl [ i ]; seg . apply ( s , t + 1 , - 1 ); if seg . prod ( 0 , n ) > 0 { ans . push ( i + 1 ); } seg . apply ( s , t + 1 , 1 ); } println! ( \"{}\" , ans . len ()); for & a in & ans { println! ( \"{}\" , a ); } }","title":"\u4f8b\u984c"},{"location":"rust/lazy_segtree/#_6","text":"\u533a\u9593\u52a0\u7b97\u66f4\u65b0 & \u533a\u9593\u52a0\u7b97\u53d6\u5f97 fn solve2 () { type P = ( i64 , i64 ); let vals = [ 1 , 2 , 3 , 4 , 5 ]; let vals = vals . iter (). map ( |& v | ( v , 1 )). collect_vec (); let op = | a : P , b : P | ( a . 0 + b . 0 , a . 1 + b . 1 ); let e = ( 0 , 0 ); let id = std :: i64 :: MAX ; let mapping = | f : i64 , x : P | { if f == id { x } else { ( f * x . 1 , x . 1 ) } }; let composition = | f : i64 , g : i64 | { if f == id { g } else { f } }; let mut seg = LazySegTree :: new_from_vec ( & vals , e , op , id , mapping , composition ); assert! ( seg . prod ( 0 , 5 ). 0 == 15 ); seg . apply ( 1 , 3 , 10 ); assert! ( seg . prod ( 0 , 3 ). 0 == 21 ); seg . apply ( 2 , 4 , - 5 ); assert! ( seg . prod ( 0 , 5 ). 0 == 6 ); seg . apply ( 0 , 1 , - 100 ); assert! ( seg . prod ( 0 , 5 ). 0 == - 95 ); }","title":"\u4f8b\u984c"},{"location":"rust/math_mod/","text":"Math (Mod) Source Code // ax + by = 1 fn _ext_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { if b == 0 { return ( 1 , 0 ); } let q = a / b ; let r = a % b ; /* (qb+r)x + by = 1 => b(qx+y) + rx = 1 => bs + rt = 1 (s.t.) s=qx+y, t=x */ let ( s , t ) = _ext_gcd ( b , r ); let x = t ; let y = s - q * t ; ( x , y ) } /* ax + by = c -> (x0, y0, xd, yd) @ x = x0 + xd*t @ y = y0 + yd*t @ x0 is minimum non-negative integer (or \"x0 < 0\" && \"xd == 0\" (e.g.) 3x = -15) NOTICE: Do not input (a,b,c) = (0,0,0) */ pub fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > { if a == 0 && b == 0 { if c == 0 { return Some (( 0 , 0 , 0 , 0 )); // exception ( any (x,y) is OK ) } return None ; } let d = num :: integer :: gcd ( a , b ); if c % d != 0 { return None ; } let ( a , b , c ) = ( a / d , b / d , c / d ); let ( mut x , mut y ) = _ext_gcd ( a , b ); x *= c ; y *= c ; if a as i128 * x as i128 + b as i128 * y as i128 == c as i128 * ( - 1 ) { x *= - 1 ; y *= - 1 ; } let ( mut xd , mut yd ) = ( b , - a ); if xd == 0 { return Some (( x , y , xd , yd )); } if xd < 0 { xd *= - 1 ; yd *= - 1 ; } /* calc min x (>= 0) */ if x >= 0 { let minus_cnt = x / xd ; x -= minus_cnt * xd ; y -= minus_cnt * yd ; } else if x < 0 { let plus_cnt = ( - x - 1 ) / xd + 1 ; x += plus_cnt * xd ; y += plus_cnt * yd ; } Some (( x , y , xd , yd )) } /* solve \"ax = 1 (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn modinv ( a : u64 , m : u64 ) -> Option < u64 > { if num :: integer :: gcd ( a , m ) != 1 || m == 0 { return None ; } let m = m as i64 ; let ( mut x , _y ) = _ext_gcd ( a as i64 , m ); x = (( x % m ) + m ) % m ; Some ( x as u64 ) } /* solve \"ax = b (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > { if m == 0 { return None ; } if m == 1 { return Some ( 0 ); // all x == all y (mod 1) } b %= m ; if a == 0 { if b == 0 { return Some ( 0 ); } return None ; } let d = num :: integer :: gcd ( a , m ); if d != 1 { if b % d != 0 { return None ; } } let ( a , b , m ) = ( a / d , b / d , m / d ); let minv = modinv ( a , m ); match minv { None => panic! ( \"something wrong. modinv always exists.\" ), Some ( v ) => Some (( b * v ) % m ), } } \u4f7f\u3044\u65b9 \u6ce8) a = 0 \u306a\u3069\u306e\u4f8b\u5916\u7684\u306a\u30b1\u30fc\u30b9\u306f\u5225\u9014\u51e6\u7406\u3057\u305f\u307b\u3046\u304c\u7121\u96e3 \u6ce8) Rust \u306e mod\u6f14\u7b97\uff08 % \uff09 \u306f\u3001\u5de6\u8fba\u304c\u8ca0\u306e\u3068\u304d\u306f\u8ca0\u3092\u8fd4\u3059\u306e\u3067\u6ce8\u610f ext_gcd ( ax + by = c ) fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x0, y0, xd, yd) x = x0 + xd*t , y = y0 + yd*t x0 \u306f\u6700\u5c0f\u306e \u975e\u8ca0\u6574\u6570 \u305f\u3060\u3057\u3001 x \u304c \u8ca0\u306e\u5024\u3057\u304b\u53d6\u3089\u306a\u3044\u6642\u306f\u305d\u306e\u5024\u3092\u8fd4\u3059\uff083x + 0y = 15 \u306a\u3069\uff09 ax_b_mod_m ( ax = b (mod m) ) fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x) (x < m) modinv ( a \u306e\u9006\u5143 (mod m) ) fn modinv ( a : u64 , m : u64 ) -> Option < u64 > \u4f8b\u984c: ext_gcd ABC186-E : kx + (-n)y = -s \u3092\u6e80\u305f\u3059\u6700\u5c0f\u306e\u975e\u8ca0\u6574\u6570 x \u3092\u6c42\u3081\u308b\u554f\u984c\u306b\u5e30\u7740\u3059\u308b fn solve_ext_gcd () { input ! { t : usize } for _ in 0 .. t { input ! { n : i64 , s : i64 , k : i64 } let v = ext_gcd ( k , - n , - s ); match v { None => println! ( \"-1\" ), Some ( v ) => { let ( x , _y , _xd , _yd ) = v ; println! ( \"{}\" , x ); } } } } \u4f8b\u984c: ax_b_mod_m ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 kx = n - s (mod n) \u3067\u89e3\u304f fn solve_ax_b_mod_m () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } let v = ax_b_mod_m ( k , n - s , n ); match v { None => println! ( \"-1\" ), Some ( x ) => { println! ( \"{}\" , x ); } } } } \u4f8b\u984c: modinv ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 k\u306e\u9006\u5143\uff08mod n\uff09 \u3092\u4e21\u8fba\u306b\u304b\u3051\u3066\u89e3\u304f fn solve_modinv () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } // k \u3068 n \u304c\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\u3068\u9006\u5143\u304c\u5b58\u5728\u3057\u306a\u3044 let g = gcd ( k , n ); if ( n - s ) % g != 0 { println! ( \"-1\" ); continue ; } // \u4ee5\u964d\u3001\u5168\u3066\u3092 k \u3068 n \u306e GCD \u3067\u5272\u3063\u305f\u5024 let kinv = modinv ( k / g , n / g ); match kinv { None => println! ( \"-1\" ), Some ( kinv ) => { let ans = (( n - s ) * kinv / g ) % ( n / g ); println! ( \"{}\" , ans ); } } } }","title":"Math (Mod)"},{"location":"rust/math_mod/#math-mod","text":"Source Code // ax + by = 1 fn _ext_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { if b == 0 { return ( 1 , 0 ); } let q = a / b ; let r = a % b ; /* (qb+r)x + by = 1 => b(qx+y) + rx = 1 => bs + rt = 1 (s.t.) s=qx+y, t=x */ let ( s , t ) = _ext_gcd ( b , r ); let x = t ; let y = s - q * t ; ( x , y ) } /* ax + by = c -> (x0, y0, xd, yd) @ x = x0 + xd*t @ y = y0 + yd*t @ x0 is minimum non-negative integer (or \"x0 < 0\" && \"xd == 0\" (e.g.) 3x = -15) NOTICE: Do not input (a,b,c) = (0,0,0) */ pub fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > { if a == 0 && b == 0 { if c == 0 { return Some (( 0 , 0 , 0 , 0 )); // exception ( any (x,y) is OK ) } return None ; } let d = num :: integer :: gcd ( a , b ); if c % d != 0 { return None ; } let ( a , b , c ) = ( a / d , b / d , c / d ); let ( mut x , mut y ) = _ext_gcd ( a , b ); x *= c ; y *= c ; if a as i128 * x as i128 + b as i128 * y as i128 == c as i128 * ( - 1 ) { x *= - 1 ; y *= - 1 ; } let ( mut xd , mut yd ) = ( b , - a ); if xd == 0 { return Some (( x , y , xd , yd )); } if xd < 0 { xd *= - 1 ; yd *= - 1 ; } /* calc min x (>= 0) */ if x >= 0 { let minus_cnt = x / xd ; x -= minus_cnt * xd ; y -= minus_cnt * yd ; } else if x < 0 { let plus_cnt = ( - x - 1 ) / xd + 1 ; x += plus_cnt * xd ; y += plus_cnt * yd ; } Some (( x , y , xd , yd )) } /* solve \"ax = 1 (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn modinv ( a : u64 , m : u64 ) -> Option < u64 > { if num :: integer :: gcd ( a , m ) != 1 || m == 0 { return None ; } let m = m as i64 ; let ( mut x , _y ) = _ext_gcd ( a as i64 , m ); x = (( x % m ) + m ) % m ; Some ( x as u64 ) } /* solve \"ax = b (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > { if m == 0 { return None ; } if m == 1 { return Some ( 0 ); // all x == all y (mod 1) } b %= m ; if a == 0 { if b == 0 { return Some ( 0 ); } return None ; } let d = num :: integer :: gcd ( a , m ); if d != 1 { if b % d != 0 { return None ; } } let ( a , b , m ) = ( a / d , b / d , m / d ); let minv = modinv ( a , m ); match minv { None => panic! ( \"something wrong. modinv always exists.\" ), Some ( v ) => Some (( b * v ) % m ), } }","title":"Math (Mod)"},{"location":"rust/math_mod/#_1","text":"\u6ce8) a = 0 \u306a\u3069\u306e\u4f8b\u5916\u7684\u306a\u30b1\u30fc\u30b9\u306f\u5225\u9014\u51e6\u7406\u3057\u305f\u307b\u3046\u304c\u7121\u96e3 \u6ce8) Rust \u306e mod\u6f14\u7b97\uff08 % \uff09 \u306f\u3001\u5de6\u8fba\u304c\u8ca0\u306e\u3068\u304d\u306f\u8ca0\u3092\u8fd4\u3059\u306e\u3067\u6ce8\u610f","title":"\u4f7f\u3044\u65b9"},{"location":"rust/math_mod/#ext_gcd-ax-by-c","text":"fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x0, y0, xd, yd) x = x0 + xd*t , y = y0 + yd*t x0 \u306f\u6700\u5c0f\u306e \u975e\u8ca0\u6574\u6570 \u305f\u3060\u3057\u3001 x \u304c \u8ca0\u306e\u5024\u3057\u304b\u53d6\u3089\u306a\u3044\u6642\u306f\u305d\u306e\u5024\u3092\u8fd4\u3059\uff083x + 0y = 15 \u306a\u3069\uff09","title":"ext_gcd ( ax + by = c )"},{"location":"rust/math_mod/#ax_b_mod_m-ax-b-mod-m","text":"fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x) (x < m)","title":"ax_b_mod_m ( ax = b (mod m) )"},{"location":"rust/math_mod/#modinv-a-mod-m","text":"fn modinv ( a : u64 , m : u64 ) -> Option < u64 >","title":"modinv ( a \u306e\u9006\u5143 (mod m) )"},{"location":"rust/math_mod/#ext_gcd","text":"ABC186-E : kx + (-n)y = -s \u3092\u6e80\u305f\u3059\u6700\u5c0f\u306e\u975e\u8ca0\u6574\u6570 x \u3092\u6c42\u3081\u308b\u554f\u984c\u306b\u5e30\u7740\u3059\u308b fn solve_ext_gcd () { input ! { t : usize } for _ in 0 .. t { input ! { n : i64 , s : i64 , k : i64 } let v = ext_gcd ( k , - n , - s ); match v { None => println! ( \"-1\" ), Some ( v ) => { let ( x , _y , _xd , _yd ) = v ; println! ( \"{}\" , x ); } } } }","title":"\u4f8b\u984c: ext_gcd"},{"location":"rust/math_mod/#ax_b_mod_m","text":"ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 kx = n - s (mod n) \u3067\u89e3\u304f fn solve_ax_b_mod_m () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } let v = ax_b_mod_m ( k , n - s , n ); match v { None => println! ( \"-1\" ), Some ( x ) => { println! ( \"{}\" , x ); } } } }","title":"\u4f8b\u984c: ax_b_mod_m"},{"location":"rust/math_mod/#modinv","text":"ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 k\u306e\u9006\u5143\uff08mod n\uff09 \u3092\u4e21\u8fba\u306b\u304b\u3051\u3066\u89e3\u304f fn solve_modinv () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } // k \u3068 n \u304c\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\u3068\u9006\u5143\u304c\u5b58\u5728\u3057\u306a\u3044 let g = gcd ( k , n ); if ( n - s ) % g != 0 { println! ( \"-1\" ); continue ; } // \u4ee5\u964d\u3001\u5168\u3066\u3092 k \u3068 n \u306e GCD \u3067\u5272\u3063\u305f\u5024 let kinv = modinv ( k / g , n / g ); match kinv { None => println! ( \"-1\" ), Some ( kinv ) => { let ans = (( n - s ) * kinv / g ) % ( n / g ); println! ( \"{}\" , ans ); } } } }","title":"\u4f8b\u984c: modinv"},{"location":"rust/math_pow/","text":"Source Code fn pow_mod ( base : u64 , exp : u64 , m : u64 ) -> u64 { let mut res = 1 ; let mut curr_val = base ; let mut exp_rem = exp ; while exp_rem > 0 { if exp_rem & 1 == 1 { res *= curr_val ; res %= m ; } curr_val *= curr_val ; curr_val %= m ; exp_rem >>= 1 ; } res } macro_rules! pow_mod { ( $base : expr , $exp : expr , $mo : expr ) => { pow_mod ( $base as u64 , $exp as u64 , $mo as u64 ) }; } \u4f7f\u3044\u65b9 let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"Math pow"},{"location":"rust/math_pow/#_1","text":"let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"\u4f7f\u3044\u65b9"},{"location":"rust/maxflow/","text":"MaxFlowDinic Source Code #[derive(Clone, Copy, Debug, PartialEq, Eq)] pub struct Edge { from : usize , to : usize , rev : usize , cap : u64 , flow : u64 , } pub struct MaxFlowDinic { n : usize , edges : Vec < Vec < Edge >> , edges_pos : Vec < ( usize , usize ) > , } impl MaxFlowDinic { pub fn new ( n : usize ) -> Self { let edges = vec! [ vec! []; n ]; MaxFlowDinic { n , edges , edges_pos : vec ! [], } } pub fn add_edge ( & mut self , from : usize , to : usize , cap : u64 ) -> usize { let to_rev = self . edges [ to ]. len (); let from_rev = self . edges [ from ]. len (); self . edges_pos . push (( from , self . edges [ from ]. len ())); self . edges [ from ]. push ( Edge { from , to , cap , rev : to_rev , flow : 0 , }); self . edges [ to ]. push ( Edge { from , to : from , cap : 0 , rev : from_rev , flow : 0 , }); self . edges_pos . len () - 1 } pub fn get_edge ( & self , i : usize ) -> Edge { assert! ( i < self . edges_pos . len ()); let pos = & self . edges_pos [ i ]; let mut edge = self . edges [ pos . 0 ][ pos . 1 ]. clone (); let rev_edge = & self . edges [ edge . to ][ edge . rev ]; edge . cap += rev_edge . cap ; edge . flow += rev_edge . cap ; edge } pub fn edges ( & self ) -> Vec < Edge > { ( 0 .. self . edges_pos . len ()) . map ( | x | self . get_edge ( x )) . collect () } pub fn flow ( & mut self , s : usize , t : usize ) -> u64 { let mut flow = 0 ; loop { let level = self . bfs ( s ); if level [ t ] < 0 { break ; } let mut iter = vec! [ 0 ; self . n ]; loop { let f = self . dfs ( s , t , std :: u64 :: MAX , & mut iter , & level ); if f == 0 { break ; } flow += f ; } } flow } pub fn min_cut ( & self , s : usize ) -> Vec < bool > { let mut vis = vec! [ false ; self . n ]; let mut q = VecDeque :: new (); vis [ s ] = true ; q . push_back ( s ); while let Some ( poped ) = q . pop_front () { for & edge in & self . edges [ poped ] { if ! vis [ edge . to ] && edge . cap > 0 { vis [ edge . to ] = true ; q . push_back ( edge . to ); } } } vis } fn bfs ( & self , s : usize ) -> Vec < i64 > { let mut level = vec! [ - 1 ; self . n ]; let mut q = VecDeque :: new (); q . push_back ( s ); level [ s ] = 0 ; while let Some ( poped ) = q . pop_front () { for edge in & self . edges [ poped ] { if level [ edge . to ] == - 1 && edge . cap > 0 { level [ edge . to ] = level [ poped ] + 1 ; q . push_back ( edge . to ); } } } level } fn dfs ( & mut self , v : usize , t : usize , up : u64 , ite : & mut Vec < usize > , level : & Vec < i64 > ) -> u64 { if v == t { return up ; }; while ite [ v ] < self . edges [ v ]. len () { let e = self . edges [ v ][ ite [ v ]]; let up = up . min ( e . cap ); if up > 0 && level [ v ] < level [ e . to ] { let d = self . dfs ( e . to , t , up , ite , level ); if d > 0 { let rev = self . edges [ v ][ ite [ v ]]. rev ; self . edges [ v ][ ite [ v ]]. cap -= d ; self . edges [ e . to ][ rev ]. cap += d ; return d ; } } ite [ v ] += 1 ; } 0 } } \u4f7f\u3044\u65b9 \u521d\u671f\u5316 let mut g = MaxFlowDinic :: new ( n ); # n : \u9802\u70b9\u6570 \u30a8\u30c3\u30b8\u8ffd\u52a0 g . add_edge ( u , v , cap : u64 ); \u6700\u5927\u30d5\u30ed\u30fc let flow_value : u64 = g . flow ( s , t ) \u6700\u5c0f\u30ab\u30c3\u30c8 let flow_value : Vec < bool > = g . flow ( s ) \u6700\u5c0f\u30ab\u30c3\u30c8\u5f8c\u306b s \u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u304c true \u6ce8) flow() \u30921\u5ea6\u8aad\u3093\u3060\u5f8c\u306b\u4f7f\u7528\u53ef\u80fd \u4f8b\u984c ABC239-G : s-t\u30ab\u30c3\u30c8\u306b\u843d\u3068\u3057\u8fbc\u3080 fn solve () { input ! { n : usize , m : usize , gl : [( Usize1 , Usize1 ); m ], mut cl : [ u64 ; n ], } /* [\u65b9\u91dd] \u4f7f\u7528\u4e0d\u53ef\u306b\u3059\u308b\u9802\u70b9\u3092\u6c7a\u3081\u308b\u305f\u3081\u306b... - \u5404\u9802\u70b9\u306b\u8d85\u9802\u70b9\u3092\u7528\u610f\u3059\u308b - \u305d\u306e\u8d85\u9802\u70b9\u3078\u306e\u30a8\u30c3\u30b8\u304c\u30ab\u30c3\u30c8\u3055\u308c\u308b => \u305d\u306e\u9802\u70b9\u304c\u5b9f\u8cea\u4f7f\u7528\u4e0d\u53ef\u306b\u306a\u308b - \u9802\u70b9 0 & N-1 \u306f\u4f7f\u7528\u4e0d\u53ef\u306b\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u305d\u306e\u30b3\u30b9\u30c8\u3092 `inf` \u306b\u3057\u3066\u304a\u304f \u5404\u9802\u70b9\u9593\u306b\u306f cap: `inf`\uff08\u30ab\u30c3\u30c8\u4e0d\u53ef\uff09\u306e\u30a8\u30c3\u30b8\u3092\u306f\u308b */ let inf = 10e18 as u64 ; cl [ 0 ] = inf ; cl [ n - 1 ] = inf ; let mut g = MaxFlowDinic :: new ( n * 2 ); for & ( a , b ) in & gl { // \u8d85\u9802\u70b9 -> \u96a3\u63a5\u3059\u308b\u9802\u70b9 g . add_edge ( a + n , b , inf ); g . add_edge ( b + n , a , inf ); } for i in 0 .. n { // \u5404\u9802\u70b9 -> \u8d85\u9802\u70b9 g . add_edge ( i , i + n , cl [ i ]); } let ans = g . flow ( 0 , n - 1 ); // \u9802\u70b9 0 \u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306e\u53d6\u5f97 Vec<bool> let mincut = g . min_cut ( 0 ); // \u9802\u70b9\u306b\u306f\u5230\u9054\u3067\u304d\u308b\u304c\u8d85\u9802\u70b9\u306b\u306f\u5230\u9054\u3067\u304d\u306a\u3044 // -> \u8d85\u9802\u70b9\u3078\u306e\u30a8\u30c3\u30b8\u304c\u524a\u9664\u3055\u308c\u3066\u3044\u308b let ans_g = ( 1 .. n - 1 ) . filter ( |& i | mincut [ i ] && ! mincut [ i + n ]) . collect_vec (); println! ( \"{}\" , ans ); println! ( \"{}\" , ans_g . len ()); for v in ans_g { print! ( \"{} \" , v + 1 ); } println! (); }","title":"MaxFlowDinic"},{"location":"rust/maxflow/#maxflowdinic","text":"Source Code #[derive(Clone, Copy, Debug, PartialEq, Eq)] pub struct Edge { from : usize , to : usize , rev : usize , cap : u64 , flow : u64 , } pub struct MaxFlowDinic { n : usize , edges : Vec < Vec < Edge >> , edges_pos : Vec < ( usize , usize ) > , } impl MaxFlowDinic { pub fn new ( n : usize ) -> Self { let edges = vec! [ vec! []; n ]; MaxFlowDinic { n , edges , edges_pos : vec ! [], } } pub fn add_edge ( & mut self , from : usize , to : usize , cap : u64 ) -> usize { let to_rev = self . edges [ to ]. len (); let from_rev = self . edges [ from ]. len (); self . edges_pos . push (( from , self . edges [ from ]. len ())); self . edges [ from ]. push ( Edge { from , to , cap , rev : to_rev , flow : 0 , }); self . edges [ to ]. push ( Edge { from , to : from , cap : 0 , rev : from_rev , flow : 0 , }); self . edges_pos . len () - 1 } pub fn get_edge ( & self , i : usize ) -> Edge { assert! ( i < self . edges_pos . len ()); let pos = & self . edges_pos [ i ]; let mut edge = self . edges [ pos . 0 ][ pos . 1 ]. clone (); let rev_edge = & self . edges [ edge . to ][ edge . rev ]; edge . cap += rev_edge . cap ; edge . flow += rev_edge . cap ; edge } pub fn edges ( & self ) -> Vec < Edge > { ( 0 .. self . edges_pos . len ()) . map ( | x | self . get_edge ( x )) . collect () } pub fn flow ( & mut self , s : usize , t : usize ) -> u64 { let mut flow = 0 ; loop { let level = self . bfs ( s ); if level [ t ] < 0 { break ; } let mut iter = vec! [ 0 ; self . n ]; loop { let f = self . dfs ( s , t , std :: u64 :: MAX , & mut iter , & level ); if f == 0 { break ; } flow += f ; } } flow } pub fn min_cut ( & self , s : usize ) -> Vec < bool > { let mut vis = vec! [ false ; self . n ]; let mut q = VecDeque :: new (); vis [ s ] = true ; q . push_back ( s ); while let Some ( poped ) = q . pop_front () { for & edge in & self . edges [ poped ] { if ! vis [ edge . to ] && edge . cap > 0 { vis [ edge . to ] = true ; q . push_back ( edge . to ); } } } vis } fn bfs ( & self , s : usize ) -> Vec < i64 > { let mut level = vec! [ - 1 ; self . n ]; let mut q = VecDeque :: new (); q . push_back ( s ); level [ s ] = 0 ; while let Some ( poped ) = q . pop_front () { for edge in & self . edges [ poped ] { if level [ edge . to ] == - 1 && edge . cap > 0 { level [ edge . to ] = level [ poped ] + 1 ; q . push_back ( edge . to ); } } } level } fn dfs ( & mut self , v : usize , t : usize , up : u64 , ite : & mut Vec < usize > , level : & Vec < i64 > ) -> u64 { if v == t { return up ; }; while ite [ v ] < self . edges [ v ]. len () { let e = self . edges [ v ][ ite [ v ]]; let up = up . min ( e . cap ); if up > 0 && level [ v ] < level [ e . to ] { let d = self . dfs ( e . to , t , up , ite , level ); if d > 0 { let rev = self . edges [ v ][ ite [ v ]]. rev ; self . edges [ v ][ ite [ v ]]. cap -= d ; self . edges [ e . to ][ rev ]. cap += d ; return d ; } } ite [ v ] += 1 ; } 0 } }","title":"MaxFlowDinic"},{"location":"rust/maxflow/#_1","text":"","title":"\u4f7f\u3044\u65b9"},{"location":"rust/maxflow/#_2","text":"let mut g = MaxFlowDinic :: new ( n ); # n : \u9802\u70b9\u6570","title":"\u521d\u671f\u5316"},{"location":"rust/maxflow/#_3","text":"g . add_edge ( u , v , cap : u64 );","title":"\u30a8\u30c3\u30b8\u8ffd\u52a0"},{"location":"rust/maxflow/#_4","text":"let flow_value : u64 = g . flow ( s , t )","title":"\u6700\u5927\u30d5\u30ed\u30fc"},{"location":"rust/maxflow/#_5","text":"let flow_value : Vec < bool > = g . flow ( s ) \u6700\u5c0f\u30ab\u30c3\u30c8\u5f8c\u306b s \u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u304c true \u6ce8) flow() \u30921\u5ea6\u8aad\u3093\u3060\u5f8c\u306b\u4f7f\u7528\u53ef\u80fd","title":"\u6700\u5c0f\u30ab\u30c3\u30c8"},{"location":"rust/maxflow/#_6","text":"ABC239-G : s-t\u30ab\u30c3\u30c8\u306b\u843d\u3068\u3057\u8fbc\u3080 fn solve () { input ! { n : usize , m : usize , gl : [( Usize1 , Usize1 ); m ], mut cl : [ u64 ; n ], } /* [\u65b9\u91dd] \u4f7f\u7528\u4e0d\u53ef\u306b\u3059\u308b\u9802\u70b9\u3092\u6c7a\u3081\u308b\u305f\u3081\u306b... - \u5404\u9802\u70b9\u306b\u8d85\u9802\u70b9\u3092\u7528\u610f\u3059\u308b - \u305d\u306e\u8d85\u9802\u70b9\u3078\u306e\u30a8\u30c3\u30b8\u304c\u30ab\u30c3\u30c8\u3055\u308c\u308b => \u305d\u306e\u9802\u70b9\u304c\u5b9f\u8cea\u4f7f\u7528\u4e0d\u53ef\u306b\u306a\u308b - \u9802\u70b9 0 & N-1 \u306f\u4f7f\u7528\u4e0d\u53ef\u306b\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u305d\u306e\u30b3\u30b9\u30c8\u3092 `inf` \u306b\u3057\u3066\u304a\u304f \u5404\u9802\u70b9\u9593\u306b\u306f cap: `inf`\uff08\u30ab\u30c3\u30c8\u4e0d\u53ef\uff09\u306e\u30a8\u30c3\u30b8\u3092\u306f\u308b */ let inf = 10e18 as u64 ; cl [ 0 ] = inf ; cl [ n - 1 ] = inf ; let mut g = MaxFlowDinic :: new ( n * 2 ); for & ( a , b ) in & gl { // \u8d85\u9802\u70b9 -> \u96a3\u63a5\u3059\u308b\u9802\u70b9 g . add_edge ( a + n , b , inf ); g . add_edge ( b + n , a , inf ); } for i in 0 .. n { // \u5404\u9802\u70b9 -> \u8d85\u9802\u70b9 g . add_edge ( i , i + n , cl [ i ]); } let ans = g . flow ( 0 , n - 1 ); // \u9802\u70b9 0 \u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306e\u53d6\u5f97 Vec<bool> let mincut = g . min_cut ( 0 ); // \u9802\u70b9\u306b\u306f\u5230\u9054\u3067\u304d\u308b\u304c\u8d85\u9802\u70b9\u306b\u306f\u5230\u9054\u3067\u304d\u306a\u3044 // -> \u8d85\u9802\u70b9\u3078\u306e\u30a8\u30c3\u30b8\u304c\u524a\u9664\u3055\u308c\u3066\u3044\u308b let ans_g = ( 1 .. n - 1 ) . filter ( |& i | mincut [ i ] && ! mincut [ i + n ]) . collect_vec (); println! ( \"{}\" , ans ); println! ( \"{}\" , ans_g . len ()); for v in ans_g { print! ( \"{} \" , v + 1 ); } println! (); }","title":"\u4f8b\u984c"},{"location":"rust/segtree/","text":"SegTree Source Code pub struct SegTree < S : Copy + std :: fmt :: Debug , F : Fn ( S , S ) -> S > { n : usize , // the size of the original elements e : S , // identity element op : F , // size : usize , // leaf (vec) size. the whole tree size is 2*size. nodes : Vec < S > , // 1-indexed (ignore 0) } impl < S : Copy + std :: fmt :: Debug , F : Fn ( S , S ) -> S > SegTree < S , F > { pub fn new ( n : usize , e : S , op : F ) -> Self { Self :: new_from_vec ( & vec! [ e ; n ], e , op ) } pub fn new_from_vec ( vals : & Vec < S > , e : S , op : F ) -> Self { let n = vals . len (); let mut size = 1 ; while size < n { size *= 2 ; } let mut nodes = vec! [ e ; 2 * size ]; for i in 0 .. n { nodes [ size + i ] = vals [ i ]; } for i in ( 1 .. size ). rev () { nodes [ i ] = op ( nodes [ i * 2 ], nodes [ i * 2 + 1 ]); } SegTree { n , e , op , size , nodes , } } pub fn update ( & mut self , mut ind : usize , x : S ) { ind += self . size ; self . nodes [ ind ] = x ; while ind > 1 { ind >>= 1 ; self . nodes [ ind ] = ( self . op )( self . nodes [ ind * 2 ], self . nodes [ ind * 2 + 1 ]); } } pub fn prod ( & self , mut l : usize , mut r : usize ) -> S { l += self . size ; r += self . size ; let mut lv = self . e ; let mut rv = self . e ; while l < r { if l & 1 == 1 { lv = ( self . op )( lv , self . nodes [ l ]); l += 1 ; } if r & 1 == 1 { rv = ( self . op )( self . nodes [ r - 1 ], rv ); r -= 1 ; } l >>= 1 ; r >>= 1 ; } ( self . op )( lv , rv ) } pub fn print_vals ( & self ) { println! ( \"{:?}\" , self . nodes [ self . size .. self . size + self . n ] . iter () . collect :: < Vec < _ >> () ); } } \u4f7f\u3044\u65b9 \u521d\u671f\u5316 let mut seg = SegTree :: new_from_vec ( & vals : Vec < S > , e : S , op : F ); vals : \u521d\u671f\u306e Vec e : \u5358\u4f4d\u5143\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 0 \u3001\u533a\u9593 min \u306a\u3089 INF \uff09 op : \u4e8c\u9805\u6f14\u7b97\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 |a,b| a+b \uff09 \u66f4\u65b0 seg . update ( index , value ) \u5024\u53d6\u5f97 seg . prod ( left , right ) # [ left , right ) \u4f8b\u984c ABC185-F : \u533a\u9593\u306eXOR\u53d6\u5f97 & 1\u70b9\u66f4\u65b0 fn main () { input ! { n : usize , q : usize , al : [ u64 ; n ], } let mut seg = SegTree :: new_from_vec ( & al , 0 , | a , b | a ^ b ); for _ in 0 .. q { input ! { t : usize , x : usize , y : usize , } if t == 1 { seg . update ( x - 1 , seg . prod ( x - 1 , x ) ^ y as u64 ); } else { let ans = seg . prod ( x - 1 , y ); println! ( \"{}\" , ans ); } } }","title":"SegTree"},{"location":"rust/segtree/#segtree","text":"Source Code pub struct SegTree < S : Copy + std :: fmt :: Debug , F : Fn ( S , S ) -> S > { n : usize , // the size of the original elements e : S , // identity element op : F , // size : usize , // leaf (vec) size. the whole tree size is 2*size. nodes : Vec < S > , // 1-indexed (ignore 0) } impl < S : Copy + std :: fmt :: Debug , F : Fn ( S , S ) -> S > SegTree < S , F > { pub fn new ( n : usize , e : S , op : F ) -> Self { Self :: new_from_vec ( & vec! [ e ; n ], e , op ) } pub fn new_from_vec ( vals : & Vec < S > , e : S , op : F ) -> Self { let n = vals . len (); let mut size = 1 ; while size < n { size *= 2 ; } let mut nodes = vec! [ e ; 2 * size ]; for i in 0 .. n { nodes [ size + i ] = vals [ i ]; } for i in ( 1 .. size ). rev () { nodes [ i ] = op ( nodes [ i * 2 ], nodes [ i * 2 + 1 ]); } SegTree { n , e , op , size , nodes , } } pub fn update ( & mut self , mut ind : usize , x : S ) { ind += self . size ; self . nodes [ ind ] = x ; while ind > 1 { ind >>= 1 ; self . nodes [ ind ] = ( self . op )( self . nodes [ ind * 2 ], self . nodes [ ind * 2 + 1 ]); } } pub fn prod ( & self , mut l : usize , mut r : usize ) -> S { l += self . size ; r += self . size ; let mut lv = self . e ; let mut rv = self . e ; while l < r { if l & 1 == 1 { lv = ( self . op )( lv , self . nodes [ l ]); l += 1 ; } if r & 1 == 1 { rv = ( self . op )( self . nodes [ r - 1 ], rv ); r -= 1 ; } l >>= 1 ; r >>= 1 ; } ( self . op )( lv , rv ) } pub fn print_vals ( & self ) { println! ( \"{:?}\" , self . nodes [ self . size .. self . size + self . n ] . iter () . collect :: < Vec < _ >> () ); } }","title":"SegTree"},{"location":"rust/segtree/#_1","text":"","title":"\u4f7f\u3044\u65b9"},{"location":"rust/segtree/#_2","text":"let mut seg = SegTree :: new_from_vec ( & vals : Vec < S > , e : S , op : F ); vals : \u521d\u671f\u306e Vec e : \u5358\u4f4d\u5143\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 0 \u3001\u533a\u9593 min \u306a\u3089 INF \uff09 op : \u4e8c\u9805\u6f14\u7b97\uff08\u4f8b: \u533a\u9593\u52a0\u7b97\u306a\u3089 |a,b| a+b \uff09","title":"\u521d\u671f\u5316"},{"location":"rust/segtree/#_3","text":"seg . update ( index , value )","title":"\u66f4\u65b0"},{"location":"rust/segtree/#_4","text":"seg . prod ( left , right ) # [ left , right )","title":"\u5024\u53d6\u5f97"},{"location":"rust/segtree/#_5","text":"ABC185-F : \u533a\u9593\u306eXOR\u53d6\u5f97 & 1\u70b9\u66f4\u65b0 fn main () { input ! { n : usize , q : usize , al : [ u64 ; n ], } let mut seg = SegTree :: new_from_vec ( & al , 0 , | a , b | a ^ b ); for _ in 0 .. q { input ! { t : usize , x : usize , y : usize , } if t == 1 { seg . update ( x - 1 , seg . prod ( x - 1 , x ) ^ y as u64 ); } else { let ans = seg . prod ( x - 1 , y ); println! ( \"{}\" , ans ); } } }","title":"\u4f8b\u984c"},{"location":"rust/util/","text":"Util \u6587\u5b57\u306e\u8ddd\u96e2 let ch = 'F' ; let d = ch as u32 - 'A' as u32 ;","title":"Util"},{"location":"rust/util/#util","text":"","title":"Util"},{"location":"rust/util/#_1","text":"let ch = 'F' ; let d = ch as u32 - 'A' as u32 ;","title":"\u6587\u5b57\u306e\u8ddd\u96e2"},{"location":"rust/math/integer/","text":"Integer Source Code // ax + by = 1 fn _ext_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { if b == 0 { return ( 1 , 0 ); } let q = a / b ; let r = a % b ; /* (qb+r)x + by = 1 => b(qx+y) + rx = 1 => bs + rt = 1 (s.t.) s=qx+y, t=x */ let ( s , t ) = _ext_gcd ( b , r ); let x = t ; let y = s - q * t ; ( x , y ) } /* ax + by = c -> (x0, y0, xd, yd) @ x = x0 + xd*t @ y = y0 + yd*t @ x0 is minimum non-negative integer (or \"x0 < 0\" && \"xd == 0\" (e.g.) 3x = -15) NOTICE: Do not input (a,b,c) = (0,0,0) */ pub fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > { if a == 0 && b == 0 { if c == 0 { return Some (( 0 , 0 , 0 , 0 )); // exception ( any (x,y) is OK ) } return None ; } let d = num :: integer :: gcd ( a , b ); if c % d != 0 { return None ; } let ( a , b , c ) = ( a / d , b / d , c / d ); let ( mut x , mut y ) = _ext_gcd ( a , b ); x *= c ; y *= c ; if a as i128 * x as i128 + b as i128 * y as i128 == c as i128 * ( - 1 ) { x *= - 1 ; y *= - 1 ; } let ( mut xd , mut yd ) = ( b , - a ); if xd == 0 { return Some (( x , y , xd , yd )); } if xd < 0 { xd *= - 1 ; yd *= - 1 ; } /* calc min x (>= 0) */ if x >= 0 { let minus_cnt = x / xd ; x -= minus_cnt * xd ; y -= minus_cnt * yd ; } else if x < 0 { let plus_cnt = ( - x - 1 ) / xd + 1 ; x += plus_cnt * xd ; y += plus_cnt * yd ; } Some (( x , y , xd , yd )) } /* solve \"ax = 1 (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn modinv ( a : u64 , m : u64 ) -> Option < u64 > { if num :: integer :: gcd ( a , m ) != 1 || m == 0 { return None ; } let m = m as i64 ; let ( mut x , _y ) = _ext_gcd ( a as i64 , m ); x = (( x % m ) + m ) % m ; Some ( x as u64 ) } /* solve \"ax = b (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > { if m == 0 { return None ; } if m == 1 { return Some ( 0 ); // all x == all y (mod 1) } b %= m ; if a == 0 { if b == 0 { return Some ( 0 ); } return None ; } let d = num :: integer :: gcd ( a , m ); if d != 1 { if b % d != 0 { return None ; } } let ( a , b , m ) = ( a / d , b / d , m / d ); let minv = modinv ( a , m ); match minv { None => panic! ( \"something wrong. modinv always exists.\" ), Some ( v ) => Some (( b * v ) % m ), } } \u4f7f\u3044\u65b9 \u6ce8) a = 0 \u306a\u3069\u306e\u4f8b\u5916\u7684\u306a\u30b1\u30fc\u30b9\u306f\u5225\u9014\u51e6\u7406\u3057\u305f\u307b\u3046\u304c\u7121\u96e3 \u6ce8) Rust \u306e mod\u6f14\u7b97\uff08 % \uff09 \u306f\u3001\u5de6\u8fba\u304c\u8ca0\u306e\u3068\u304d\u306f\u8ca0\u3092\u8fd4\u3059\u306e\u3067\u6ce8\u610f ext_gcd ( ax + by = c ) fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x0, y0, xd, yd) x = x0 + xd*t , y = y0 + yd*t x0 \u306f\u6700\u5c0f\u306e \u975e\u8ca0\u6574\u6570 \u305f\u3060\u3057\u3001 x \u304c \u8ca0\u306e\u5024\u3057\u304b\u53d6\u3089\u306a\u3044\u6642\u306f\u305d\u306e\u5024\u3092\u8fd4\u3059\uff083x + 0y = 15 \u306a\u3069\uff09 ax_b_mod_m ( ax = b (mod m) ) fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x) (x < m) modinv ( a \u306e\u9006\u5143 (mod m) ) fn modinv ( a : u64 , m : u64 ) -> Option < u64 > \u4f8b\u984c: ext_gcd ABC186-E : kx + (-n)y = -s \u3092\u6e80\u305f\u3059\u6700\u5c0f\u306e\u975e\u8ca0\u6574\u6570 x \u3092\u6c42\u3081\u308b\u554f\u984c\u306b\u5e30\u7740\u3059\u308b fn solve_ext_gcd () { input ! { t : usize } for _ in 0 .. t { input ! { n : i64 , s : i64 , k : i64 } let v = ext_gcd ( k , - n , - s ); match v { None => println! ( \"-1\" ), Some ( v ) => { let ( x , _y , _xd , _yd ) = v ; println! ( \"{}\" , x ); } } } } \u4f8b\u984c: ax_b_mod_m ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 kx = n - s (mod n) \u3067\u89e3\u304f fn solve_ax_b_mod_m () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } let v = ax_b_mod_m ( k , n - s , n ); match v { None => println! ( \"-1\" ), Some ( x ) => { println! ( \"{}\" , x ); } } } } \u4f8b\u984c: modinv ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 k\u306e\u9006\u5143\uff08mod n\uff09 \u3092\u4e21\u8fba\u306b\u304b\u3051\u3066\u89e3\u304f fn solve_modinv () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } // k \u3068 n \u304c\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\u3068\u9006\u5143\u304c\u5b58\u5728\u3057\u306a\u3044 let g = gcd ( k , n ); if ( n - s ) % g != 0 { println! ( \"-1\" ); continue ; } // \u4ee5\u964d\u3001\u5168\u3066\u3092 k \u3068 n \u306e GCD \u3067\u5272\u3063\u305f\u5024 let kinv = modinv ( k / g , n / g ); match kinv { None => println! ( \"-1\" ), Some ( kinv ) => { let ans = (( n - s ) * kinv / g ) % ( n / g ); println! ( \"{}\" , ans ); } } } }","title":"Integer"},{"location":"rust/math/integer/#integer","text":"Source Code // ax + by = 1 fn _ext_gcd ( a : i64 , b : i64 ) -> ( i64 , i64 ) { if b == 0 { return ( 1 , 0 ); } let q = a / b ; let r = a % b ; /* (qb+r)x + by = 1 => b(qx+y) + rx = 1 => bs + rt = 1 (s.t.) s=qx+y, t=x */ let ( s , t ) = _ext_gcd ( b , r ); let x = t ; let y = s - q * t ; ( x , y ) } /* ax + by = c -> (x0, y0, xd, yd) @ x = x0 + xd*t @ y = y0 + yd*t @ x0 is minimum non-negative integer (or \"x0 < 0\" && \"xd == 0\" (e.g.) 3x = -15) NOTICE: Do not input (a,b,c) = (0,0,0) */ pub fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > { if a == 0 && b == 0 { if c == 0 { return Some (( 0 , 0 , 0 , 0 )); // exception ( any (x,y) is OK ) } return None ; } let d = num :: integer :: gcd ( a , b ); if c % d != 0 { return None ; } let ( a , b , c ) = ( a / d , b / d , c / d ); let ( mut x , mut y ) = _ext_gcd ( a , b ); x *= c ; y *= c ; if a as i128 * x as i128 + b as i128 * y as i128 == c as i128 * ( - 1 ) { x *= - 1 ; y *= - 1 ; } let ( mut xd , mut yd ) = ( b , - a ); if xd == 0 { return Some (( x , y , xd , yd )); } if xd < 0 { xd *= - 1 ; yd *= - 1 ; } /* calc min x (>= 0) */ if x >= 0 { let minus_cnt = x / xd ; x -= minus_cnt * xd ; y -= minus_cnt * yd ; } else if x < 0 { let plus_cnt = ( - x - 1 ) / xd + 1 ; x += plus_cnt * xd ; y += plus_cnt * yd ; } Some (( x , y , xd , yd )) } /* solve \"ax = 1 (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn modinv ( a : u64 , m : u64 ) -> Option < u64 > { if num :: integer :: gcd ( a , m ) != 1 || m == 0 { return None ; } let m = m as i64 ; let ( mut x , _y ) = _ext_gcd ( a as i64 , m ); x = (( x % m ) + m ) % m ; Some ( x as u64 ) } /* solve \"ax = b (mod m)\" NOTICE: if m == 1 -> x = 0 */ pub fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > { if m == 0 { return None ; } if m == 1 { return Some ( 0 ); // all x == all y (mod 1) } b %= m ; if a == 0 { if b == 0 { return Some ( 0 ); } return None ; } let d = num :: integer :: gcd ( a , m ); if d != 1 { if b % d != 0 { return None ; } } let ( a , b , m ) = ( a / d , b / d , m / d ); let minv = modinv ( a , m ); match minv { None => panic! ( \"something wrong. modinv always exists.\" ), Some ( v ) => Some (( b * v ) % m ), } }","title":"Integer"},{"location":"rust/math/integer/#_1","text":"\u6ce8) a = 0 \u306a\u3069\u306e\u4f8b\u5916\u7684\u306a\u30b1\u30fc\u30b9\u306f\u5225\u9014\u51e6\u7406\u3057\u305f\u307b\u3046\u304c\u7121\u96e3 \u6ce8) Rust \u306e mod\u6f14\u7b97\uff08 % \uff09 \u306f\u3001\u5de6\u8fba\u304c\u8ca0\u306e\u3068\u304d\u306f\u8ca0\u3092\u8fd4\u3059\u306e\u3067\u6ce8\u610f","title":"\u4f7f\u3044\u65b9"},{"location":"rust/math/integer/#ext_gcd-ax-by-c","text":"fn ext_gcd ( a : i64 , b : i64 , c : i64 ) -> Option < ( i64 , i64 , i64 , i64 ) > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x0, y0, xd, yd) x = x0 + xd*t , y = y0 + yd*t x0 \u306f\u6700\u5c0f\u306e \u975e\u8ca0\u6574\u6570 \u305f\u3060\u3057\u3001 x \u304c \u8ca0\u306e\u5024\u3057\u304b\u53d6\u3089\u306a\u3044\u6642\u306f\u305d\u306e\u5024\u3092\u8fd4\u3059\uff083x + 0y = 15 \u306a\u3069\uff09","title":"ext_gcd ( ax + by = c )"},{"location":"rust/math/integer/#ax_b_mod_m-ax-b-mod-m","text":"fn ax_b_mod_m ( a : u64 , mut b : u64 , m : u64 ) -> Option < u64 > \u89e3\u306a\u3057\u306e\u3068\u304d\u306f None \u89e3\u3042\u308a\u306e\u3068\u304d\u306f Some(x) (x < m)","title":"ax_b_mod_m ( ax = b (mod m) )"},{"location":"rust/math/integer/#modinv-a-mod-m","text":"fn modinv ( a : u64 , m : u64 ) -> Option < u64 >","title":"modinv ( a \u306e\u9006\u5143 (mod m) )"},{"location":"rust/math/integer/#ext_gcd","text":"ABC186-E : kx + (-n)y = -s \u3092\u6e80\u305f\u3059\u6700\u5c0f\u306e\u975e\u8ca0\u6574\u6570 x \u3092\u6c42\u3081\u308b\u554f\u984c\u306b\u5e30\u7740\u3059\u308b fn solve_ext_gcd () { input ! { t : usize } for _ in 0 .. t { input ! { n : i64 , s : i64 , k : i64 } let v = ext_gcd ( k , - n , - s ); match v { None => println! ( \"-1\" ), Some ( v ) => { let ( x , _y , _xd , _yd ) = v ; println! ( \"{}\" , x ); } } } }","title":"\u4f8b\u984c: ext_gcd"},{"location":"rust/math/integer/#ax_b_mod_m","text":"ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 kx = n - s (mod n) \u3067\u89e3\u304f fn solve_ax_b_mod_m () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } let v = ax_b_mod_m ( k , n - s , n ); match v { None => println! ( \"-1\" ), Some ( x ) => { println! ( \"{}\" , x ); } } } }","title":"\u4f8b\u984c: ax_b_mod_m"},{"location":"rust/math/integer/#modinv","text":"ABC186-E : \u2191\u3068\u540c\u3058\u554f\u984c\u3092 k\u306e\u9006\u5143\uff08mod n\uff09 \u3092\u4e21\u8fba\u306b\u304b\u3051\u3066\u89e3\u304f fn solve_modinv () { input ! { t : usize } for _ in 0 .. t { input ! { n : u64 , s : u64 , k : u64 } // k \u3068 n \u304c\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\u3068\u9006\u5143\u304c\u5b58\u5728\u3057\u306a\u3044 let g = gcd ( k , n ); if ( n - s ) % g != 0 { println! ( \"-1\" ); continue ; } // \u4ee5\u964d\u3001\u5168\u3066\u3092 k \u3068 n \u306e GCD \u3067\u5272\u3063\u305f\u5024 let kinv = modinv ( k / g , n / g ); match kinv { None => println! ( \"-1\" ), Some ( kinv ) => { let ans = (( n - s ) * kinv / g ) % ( n / g ); println! ( \"{}\" , ans ); } } } }","title":"\u4f8b\u984c: modinv"},{"location":"rust/math/pow/","text":"Pow Source Code fn pow_mod ( base : u64 , exp : u64 , m : u64 ) -> u64 { let mut res = 1 ; let mut curr_val = base ; let mut exp_rem = exp ; while exp_rem > 0 { if exp_rem & 1 == 1 { res *= curr_val ; res %= m ; } curr_val *= curr_val ; curr_val %= m ; exp_rem >>= 1 ; } res } macro_rules! pow_mod { ( $base : expr , $exp : expr , $mo : expr ) => { pow_mod ( $base as u64 , $exp as u64 , $mo as u64 ) }; } \u4f7f\u3044\u65b9 let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"Pow"},{"location":"rust/math/pow/#pow","text":"Source Code fn pow_mod ( base : u64 , exp : u64 , m : u64 ) -> u64 { let mut res = 1 ; let mut curr_val = base ; let mut exp_rem = exp ; while exp_rem > 0 { if exp_rem & 1 == 1 { res *= curr_val ; res %= m ; } curr_val *= curr_val ; curr_val %= m ; exp_rem >>= 1 ; } res } macro_rules! pow_mod { ( $base : expr , $exp : expr , $mo : expr ) => { pow_mod ( $base as u64 , $exp as u64 , $mo as u64 ) }; }","title":"Pow"},{"location":"rust/math/pow/#_1","text":"let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"\u4f7f\u3044\u65b9"},{"location":"rust/math/pow_mod/","text":"PowMod Source Code fn pow_mod ( base : u64 , exp : u64 , m : u64 ) -> u64 { let mut res = 1 ; let mut curr_val = base ; let mut exp_rem = exp ; while exp_rem > 0 { if exp_rem & 1 == 1 { res *= curr_val ; res %= m ; } curr_val *= curr_val ; curr_val %= m ; exp_rem >>= 1 ; } res } macro_rules! pow_mod { ( $base : expr , $exp : expr , $mo : expr ) => { pow_mod ( $base as u64 , $exp as u64 , $mo as u64 ) }; } \u4f7f\u3044\u65b9 let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"PowMod"},{"location":"rust/math/pow_mod/#powmod","text":"Source Code fn pow_mod ( base : u64 , exp : u64 , m : u64 ) -> u64 { let mut res = 1 ; let mut curr_val = base ; let mut exp_rem = exp ; while exp_rem > 0 { if exp_rem & 1 == 1 { res *= curr_val ; res %= m ; } curr_val *= curr_val ; curr_val %= m ; exp_rem >>= 1 ; } res } macro_rules! pow_mod { ( $base : expr , $exp : expr , $mo : expr ) => { pow_mod ( $base as u64 , $exp as u64 , $mo as u64 ) }; }","title":"PowMod"},{"location":"rust/math/pow_mod/#_1","text":"let x = pow_mod ! ( 2 , 1000 ); \u578b\u306f u64 \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u3067\u3042\u308c\u3070 OK","title":"\u4f7f\u3044\u65b9"}]}